
Когда мы запускаем какую-то программу на Python происходит четыре шага: 

1. лексической анализ
2. парсинг
3. компиляция
4. интерпретация

Парсер забирает скормленные ему инструкции и генерирует структуру которая объясняет их связь формируя [AST](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)( Абстрактное Синтаксическое Дерево). Компилятор затем преобразует AST в одни (или несколько) объектов кода (байткод + обвязка). Потом интерпретатор выполняет каждый объект.

# Интерпретатор

Сначала у нас запускает компилятор (да в Python все-таки он есть хоть и урезанный). Он входит в состав интерпретатора. Компилятор делает следующее:

- проверяет синтаксис программы: закрытие скобок, отступы ещё до запуска программы.
- НО В ОТЛИЧИИ от полноценных компиляторов в других языках не проверяет математические косяки и типизацию.
- Преобразует программу в байт-код (в низкоуровневую запись программы)
- Если это первый запуск или вы вносили какие-то изменения в программе, то компилятор ещё и отправляет полученный байт-код в папку `__pyCache__`. Если байт код уже был сгенерирован, то байт-код просто достается из папки и компилятор не делает это преобразование ещё раз, готовый байт-код идет сразу в виртуальную машину.

На этом роль компилятора закончена, если вам не выдало синтаксическую ошибку, то программа продолжает свой путь к "выполнению". Байт код передает в виртуальную машину. И он начинает непосредственно выполняться. Происходит общение с ОС. И мы получаем результат. 

В чем плюс такого подхода реализации интерпретатора:

Если у нас есть синтаксические ошибки, наш код не дойдет до этапа попадания в виртуальную машину. 

В чем минус:

Если у нас есть математические ошибки (пример деление на ноль в коде), то компилятор Python это "скушает", он сделает байт-код и отправит его в виртуальную машину. Программа "упадет" уже непосредственно при выполнении в ОС. 