

> [!NOTE] Кратко
> При вычислениях и округлениях объектов float могут возникать странности. 
> Для решения можно использовать библиотеку Decimal или fractions или пакет Numeric



Подробно о проблеме:

[Числа с плавающей точкой](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-float-veschestvennye-chisla/ "Вещественные числа float в Python.") представлены в компьютерах в виде двоичных дробей. Например, десятичная дробь `0.125` имеет значение `1/10 + 2/100 + 5/1000`, и таким же образом двоичная дробь `0.001` имеет значение `0/2 + 0/4 + 1/8`. Эти две дроби имеют одинаковые значения, единственное реальное отличие состоит в том, что первая записана в дробной записи с основанием 10, а вторая - с основанием 2.

К сожалению, [большинство десятичных дробей не могут быть представлены точно как двоичные дроби](https://docs-python.ru/tutorial/operatsii-chislami-python/problemy-chisel-plavajuschej-zapjatoj/ "Проблемы точности чисел float в Python."). Следствием этого является то, что, как правило, вводимые десятичные числа с плавающей запятой аппроксимируются только двоичными числами с плавающей запятой, фактически сохраненными в машине.

Сначала проблему легче понять из базы 10. Рассмотрим дробь 1/3. Вы можете приблизить это как основную 10 фракцию: `0.3` или лучше, `0.33`или лучше, `0.333` и так далее. Независимо от того, сколько цифр вы хотите записать, результат никогда не будет ровно `1/3`, но будет все более приближенным к `1/3`.

Таким же образом, независимо от того, сколько цифр из 2-х оснований вы хотите использовать, десятичное значение `0,1` не может быть представлено в точности как дробь из 2-х оснований. В базе 2 `1/10` - бесконечно повторяющаяся дробь `0.0001100110011001100110011...`

Остановитесь на любом конечном количестве битов, и вы получите приближение. На большинстве современных машин числа с плавающей запятой аппроксимируются с использованием двоичной дроби, а числитель использует первые 53 бита, начиная с самого старшего бита, а знаменатель - как степень двух. В случае `1/10` двоичная дробь равна `3602879701896397/2 ** 55`, что близко, но не точно равно истинному значению `1/10`.

Многие пользователи не знают о приближении из-за способа отображения значений. Python печатает только десятичное приближение к истинному десятичному значению двоичного приближения, хранящегося на машине. На большинстве машин, если бы Python должен был печатать истинное десятичное значение двоичного приближения, хранящегося для 0.1, он должен был бы отображать

```python

>>> 0.1
# 0.1000000000000000055511151231257827021181583404541015625

```

Это больше цифр, чем большинство людей считают полезным, поэтому Python сохраняет количество цифр управляемым, отображая округленное значение вместо

```pytbon

>>> 1 / 10
# 0.1

```

Просто помните, что хотя напечатанный результат выглядит как точное значение 1/10, фактическое сохраненное значение является ближайшей представимой двоичной дробью.

Интересно, что существует много разных десятичных чисел, которые имеют одну и ту же ближайшую приблизительную двоичную дробь. Например, числа `0.1` и `0.10000000000000001` и `0.1000000000000000055511151231...` все приблизительно равны `3602879701896397/2 ** 55`. Поскольку все эти десятичные значения имеют одинаковую аппроксимацию, любое из них может отображаться при сохранении инварианта `eval(repr(x)) == x`.

Исторически Python и встроенная [функция `repr()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-repr/ "Функция repr() в Python, описание объекта.") выбирали функцию с 17 значащими цифрами, `0.10000000000000001`. Начиная с Python 3.1 в большинстве систем теперь может выбирать самый короткий из них и просто отображать 0.1.

**Обратите внимание**, что это по своей природе двоичное число с плавающей точкой: это не ошибка в Python и не ошибка в вашем коде. Вы увидите то же самое на всех языках, которые поддерживают арифметику с плавающей запятой.

Для более приятного вывода вы можете использовать [форматирование строки](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-format/ "Функция format() в Python, форматирует значение переменной.") для получения ограниченного числа значащих цифр:

```python

>>> import math
>>> format(math.pi, '.12g')
# '3.14159265359'
>>> format(math.pi, '.2f')
# '3.14'
>>> repr(math.pi)
# '3.141592653589793'

```

Важно понимать, что в действительности это иллюзия: вы просто округляете отображение истинного значения.

Одна иллюзия может породить другую. Например, поскольку 0,1 не является точно 1/10, суммирование трех значений 0,1 может также не дать точно 0,3:

```python

>>> 0.1 + 0.1 + 0.1 == 0.3
# False

Я проверил лично, блять, это говно реально дает False 

```

Кроме того, поскольку 0,1 не может приблизиться к точному значению 1/10, а 0,3 не может приблизиться к точному значению 3/10, предварительное округление [функцией `round()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-round/ "Функция round() в Python, округляет число.") может не помочь:

```python

>>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)
# False

```

Двоичная арифметика с плавающей точкой содержит много сюрпризов, подобных этому. Проблема с `0.1` подробно объясняется в разделе "[Ошибка представления](https://docs-python.ru/tutorial/operatsii-chislami-python/problemy-chisel-plavajuschej-zapjatoj/#float-error)". Смотрите также "[Опасности с плавающей точкой](http://www.lahey.com/float.htm)" для более полного описания других распространенных сюрпризов.

Как говорится, "простых ответов нет". Тем не менее, не следует чрезмерно опасаться [чисел с плавающей запятой](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-float-veschestvennye-chisla/ "Вещественные числа float в Python.")! [Ошибки в операциях с плавающей запятой Python](https://docs-python.ru/tutorial/operatsii-chislami-python/problemy-chisel-plavajuschej-zapjatoj/ "Проблемы точности чисел float в Python.") наследуются от аппаратного обеспечения чисел с плавающей запятой, и на большинстве машин они имеют порядок не более одной части в `2 ** 53` на операцию. Это более чем достаточно для большинства задач, но вам нужно помнить, что это не [десятичная арифметика](https://docs-python.ru/standart-library/modul-decimal-python/ "Модуль decimal в Python, десятичная арифметика.") и что каждая операция с плавающей запятой может подвергаться новой ошибке округления.

Несмотря на то, что патологические случаи существуют, для наиболее случайного использования арифметики с плавающей запятой вы увидите ожидаемый результат в конце, если просто округлите отображение окончательных результатов до ожидаемого количества десятичных цифр. [`str()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/klass-str/ "Класс str() в Python, преобразует объект в строку.") обычно достаточно, и для более точного управления смотрите спецификаторы формата метода [`str.format()`](https://docs-python.ru/tutorial/operatsii-tekstovymi-strokami-str-python/metod-str-format/ "Метод str.format() в Python, форматирует строку.").

Для случаев использования, которые требуют точного десятичного представления, попробуйте использовать [модуль `decimal`](https://docs-python.ru/standart-library/modul-decimal-python/ "Модуль decimal в Python, десятичная арифметика."), который реализует десятичную арифметику, подходящую для приложений бухгалтерского учета и высокоточных приложений.

Другая форма точной арифметики поддерживается [модулем `fractions`](https://docs-python.ru/standart-library/modul-fractions-python/ "Модуль fractions, рациональные числа в Python."), который реализует арифметику, основанную на рациональных числах, поэтому числа, такие как `1/3` могут быть представлены точно.

Если вы большой пользователь операций с плавающей запятой, вам следует взглянуть на пакет `Numeric Python` и многие другие пакеты для математических и статистических операций, предоставляемых [проектом `SciPy`](https://scipy.org).

Python предоставляет инструменты, которые могут помочь в тех редких случаях, когда вы действительно хотите узнать точное значение числа с плавающей точкой. Метод [`float.as_integer_ratio()`](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-float-veschestvennye-chisla/ "Вещественные числа float в Python.") выражает значение типа `float` в виде дроби:

```python

>>> x = 3.14159
>>> x.as_integer_ratio()
# (3537115888337719, 1125899906842624)

```

Поскольку отношение является точным, оно может быть использовано для воссоздания исходного значения без потерь:

```python

>>> x == 3537115888337719 / 1125899906842624
# True

```

Метод [`float.hex()`](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-float-veschestvennye-chisla/ "Вещественные числа float в Python.") выражает число с плавающей запятой в шестнадцатеричном формате (основание 16), снова давая точное значение, сохраненное компьютером:

```python

>>> x.hex()
# '0x1.921f9f01b866ep+1'

```

Это точное шестнадцатеричное представление может быть использовано для точного восстановления значения с плавающей точкой:

```python

>>> x == float.fromhex('0x1.921f9f01b866ep+1')
True

```

Поскольку представление является точным, оно полезно для надежного переноса значений между различными версиями Python и обмена данными с другими языками, поддерживающими тот же формат, например Java.

Другим полезным инструментом является [функция `math.fsum()`](https://docs-python.ru/standart-library/modul-math-python/funktsii-teorii-chisel-modulja-math/ "Функции теории чисел модуля math в Python."), которая помогает уменьшить потерю точности во время суммирования. Она отслеживает "потерянные цифры", когда значения добавляются в промежуточный итог. Это может повлиять на общую точность, так что ошибки не накапливаются до такой степени, что бы влиять на итоговую сумму:

```python

>>> import math
>>> sum([0.1] * 10) == 1.0
False
>>> math.fsum([0.1] * 10) == 1.0
True

```

