

# Кратко вспомнить

**args** и **kwargs** - это специальные параметры в Python, которые позволяют передавать переменное количество аргументов в функцию. Параметр **args** используется для передачи переменного количества аргументов без ключевого слова. Он представляет собой кортеж из всех дополнительных аргументов, переданных функции. Параметр **kwargs** используется для передачи переменного количества именованных аргументов. Он представляет собой словарь из всех дополнительных именованных аргументов, переданных функции.

Cимвол * и ** могут использоваться в определении функций для указания переменного числа аргументов, которые могут быть переданы в функцию.

Символ * перед именем параметра означает, что все позиционные аргументы, которые не были использованы при определении других параметров, будут собраны в кортеж, который можно будет использовать внутри функции. Такой параметр называется *args. Например:

# ПОДРОБНО РАЗОБРАТЬСЯ
## Позиционные и именованные аргументы

  
Для того чтобы разобраться с `*args` и `**kwargs`, нам нужно освоить концепции позиционных (positional) и именованных (keyword) аргументов.  
  
Сначала поговорим о том, чем они отличаются. В простейшей функции мы просто сопоставляем позиции аргументов и параметров. Аргумент №1 соответствует параметру №1, аргумент №2 — параметру №2 и так далее.  
  

```python

def printThese(a,b,c):
   print(a, "is stored in a")
   print(b, "is stored in b")
   print(c, "is stored in c")
printThese(1,2,3)
"""
1 is stored in a
2 is stored in b
3 is stored in c
"""

```

  
Для вызова функции необходимы все три аргумента. Если пропустить хотя бы один из них — будет выдано сообщение об ошибке.  
  

```python

def printThese(a,b,c):
   print(a, "is stored in a")
   print(b, "is stored in b")
   print(c, "is stored in c")
printThese(1,2)
"""
TypeError: printThese() missing 1 required positional argument: 'c'
"""

```

  
Если при объявлении функции назначить параметру значение по умолчанию — указывать соответствующий аргумент при вызове функции уже необязательно. Параметр становится опциональным.  
  

```python

def printThese(a,b,c=None):
   print(a, "is stored in a")
   print(b, "is stored in b")
   print(c, "is stored in c")
printThese(1,2)
"""
1 is stored in a
2 is stored in b
None is stored in c
"""

```

  
Опциональные параметры, кроме того, можно задавать при вызове функции, используя их имена.  
  
В следующем примере установим три параметра в значение по умолчанию `None` и взглянем на то, как их можно назначать, используя их имена и не обращая внимания на порядок следования аргументов, применяемых при вызове функции.  
  

```python

def printThese(a=None,b=None,c=None):
   print(a, "is stored in a")
   print(b, "is stored in b")
   print(c, "is stored in c")
printThese(c=3, a=1)
"""
1 is stored in a
None is stored in b
3 is stored in c
"""

```

  

## Оператор «звёздочка»

  
Оператор `*` чаще всего ассоциируется у людей с операцией умножения, но в Python он имеет и другой смысл.  
  
Этот оператор позволяет «распаковывать» объекты, внутри которых хранятся некие элементы. Вот пример:  
  

```python

a = [1,2,3]
b = [*a,4,5,6]
print(b) # [1,2,3,4,5,6]

```

  
Тут берётся содержимое списка `a`, распаковывается, и помещается в список `b`.  
  

## Как пользоваться *args и **kwargs

  
Итак, мы знаем о том, что оператор «звёздочка» в Python способен «вытаскивать» из объектов составляющие их элементы. Знаем мы и о том, что существует два вида параметров функций. Вполне возможно, что вы уже додумались до этого сами, но я, на всякий случай, скажу об этом. А именно, `*args` — это сокращение от «arguments» (аргументы), а **kwargs — сокращение от «keyword arguments» (именованные аргументы).  
  
Каждая из этих конструкций используется для распаковки аргументов соответствующего типа, позволяя вызывать функции со списком аргументов переменной длины. Например — создадим функцию, которая умеет выводить результаты, набранные учеником в тесте:  
  

```python

def printScores(student, *scores):
   print(f"Student Name: {student}")
   for score in scores:
      print(score)
printScores("Jonathan",100, 95, 88, 92, 99)
"""
Student Name: Jonathan
100
95
88
92
99
"""

```

  
Я не использовал при объявлении функции конструкцию `*args`. Вместо неё у меня — `*scores`. Нет ли тут ошибки? Ошибки здесь нет. Дело в том, что «args» — это всего лишь набор символов, которым принято обозначать аргументы. Самое главное тут — это оператор `*`. А то, что именно идёт после него, особой роли не играет. Благодаря использованию `*` мы создали список позиционных аргументов на основе того, что было передано функции при вызове.  
  
После того, как мы разобрались с `*args`, с пониманием `**kwargs` проблем быть уже не должно. Имя, опять же, значения не имеет. Главное — это два символа `**`. Благодаря им создаётся словарь, в котором содержатся именованные аргументы, переданные функции при её вызове.  
  

```python

def printPetNames(owner, **pets):
   print(f"Owner Name: {owner}")
   for pet,name in pets.items():
      print(f"{pet}: {name}")
printPetNames("Jonathan", dog="Brock", fish=["Larry", "Curly", "Moe"], turtle="Shelldon")
"""
Owner Name: Jonathan
dog: Brock
fish: ['Larry', 'Curly', 'Moe']
turtle: Shelldon
"""

```

  

## Итоги

  
Вот несколько советов, которые помогут вам избежать распространённых проблем, возникающих при работе с функциями, и расширить свои знания:  
  

- Используйте общепринятые конструкции `*args` и `**kwargs` для захвата позиционных и именованных аргументов.
- Конструкцию `**kwarg`s нельзя располагать до `*args`. Если это сделать — будет выдано сообщение об ошибке.
- Остерегайтесь конфликтов между именованными параметрами и `**kwargs`, в случаях, когда значение планируется передать как `**kwarg`-аргумент, но имя ключа этого значения совпадает с именем именованного параметра.
- Оператор `*`можно использовать не только в объявлениях функций, но и при их вызове.