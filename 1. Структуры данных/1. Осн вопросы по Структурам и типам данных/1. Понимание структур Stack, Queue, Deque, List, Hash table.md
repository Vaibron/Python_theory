
**Обычно используемые структуры данных**  
Давайте сначала перечислим наиболее часто используемые структуры данных, а затем рассмотрим их одну за другой:  

- Arrays — массивы
- List — списки
- Stacks — стеки
- Queues — очереди
- Linked Lists — связанные списки
- Trees — деревья
- Graphs — графы
- Tries (они, по сути, деревья, но все же хорошо называть их отдельно). — очередности
- Hash Tables — хэш таблицы

---
# Что такое массив в Python?

Массив – это совокупность элементов, которые хранятся последовательно в памяти и имеют общий тип данных. Каждому его элементу присвоен собственный индекс, который позволяет обращаться к нему для чтения или изменения го значения. **НО
В языке Python как таковых массивов нет.** Вместо этого для хранения группы однотипных (но и не только однотипных) объектов используют списки - объекты типа `list`. Отличие списков от массивов заключается в том, что список - это динамическая структура, размер которого можно изменять во время выполнения программы (удалять, добавлять элементы) не задумываясь над операциями по управлению памятью (это делает транслятор).

Ключевым достоинством массивов в Python считается их способность хранить данные различных типов. Это позволяет использовать их для различных целей: от простого хранения данных до выполнения сложных математических операций и алгоритмов. Также в них может храниться любое количество элементов, что делает их очень гибкими и удобными для работы с различными объемами данных.

Основные применения массивов в Python включают работу с большими объёмами данных, создание и использование матриц, выполнение сортировки и поиска, а также реализацию различных алгоритмов и структур данных. Таким образом, они позволяют хранить, обрабатывать и манипулировать информацией, являясь неотъемлемой частью многих программных проектов.
  
![image](https://habrastorage.org/r/w1560/webt/ir/_e/d3/ir_ed3oofkmldyxlz1sibsq5lmo.png)  
  
Каждому элементу данных присваивается положительное числовое значение, называемое индексом, которое соответствует позиции этого элемента в массиве. Большинство языков определяют начальный индекс массива как 0.  
  
Ниже приведены два типа массивов:  

- Одномерные массивы (как показано выше) One-dimensional arrays
- Многомерные массивы (массивы внутри массивов) Multi-dimensional arrays

### Если мы хотим именно Массивы в Python то есть:

Модуль array определяет массивы в python. Массивы очень похожи на [списки](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html), но с ограничением на тип данных и размер каждого элемента.

Размер и тип элемента в массиве определяется при его создании и может принимать следующие значения:

|Код типа|Тип в C|Тип в python|Минимальный размер в байтах|
|---|---|---|---|
|'b'|signed char|int|1|
|'B'|unsigned char|int|1|
|'h'|signed short|int|2|
|'H'|unsigned short|int|2|
|'i'|signed int|int|2|
|'I'|unsigned int|int|2|
|'l'|signed long|int|4|
|'L'|unsigned long|int|4|
|'q'|signed long long|int|8|
|'Q'|unsigned long long|int|8|
|'f'|float|float|4|
|'d'|double|float|8|

Класс **array.array**(TypeCode [, инициализатор]) - новый массив, элементы которого ограничены TypeCode, и инициализатор, который должен быть списком, объектом, который поддерживает интерфейс буфера, или итерируемый объект.

**array.typecodes** - строка, содержащая все возможные типы в массиве.

**Массивы изменяемы**. Массивы поддерживают все списковые методы (индексация, срезы, умножения, итерации), и другие методы.

## Методы массивов (array) в python

**array.typecode** - TypeCode символ, использованный при создании массива.

**array.itemsize** - размер в байтах одного элемента в массиве.

**array.append**(х) - добавление элемента в конец массива.

**array.buffer_info**() - кортеж (ячейка памяти, длина). Полезно для низкоуровневых операций.

**array.byteswap**() - изменить порядок следования байтов в каждом элементе массива. Полезно при чтении данных из файла, написанного на машине с другим порядком байтов.

**array.count**(х) - возвращает количество вхождений х в массив.

**array.extend**(iter) - добавление элементов из объекта в массив.

**array.frombytes**(b) - делает массив array из массива байт. Количество байт должно быть кратно размеру одного элемента в массиве.

**array.fromfile**(F, N) - читает N элементов из [файла](https://pythonworld.ru/tipy-dannyx-v-python/fajly-rabota-s-fajlami.html) и добавляет их в конец массива. Файл должен быть открыт на бинарное чтение. Если доступно меньше N элементов, генерируется [исключение](https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html) EOFError , но элементы, которые были доступны, добавляются в массив.

**array.fromlist**(список) - добавление элементов из списка.

**array.index**(х) - номер первого вхождения x в массив.

**array.insert**(n, х) - включить новый пункт со значением х в массиве перед номером n. Отрицательные значения рассматриваются относительно конца массива.

**array.pop**(i) - удаляет i-ый элемент из массива и возвращает его. По умолчанию удаляется последний элемент.

**array.remove**(х) - удалить первое вхождение х из массива.

**array.reverse**() - обратный порядок элементов в массиве.

**array.tobytes**() - преобразование к байтам.

**array.tofile**(f) - запись массива в открытый файл.

**array.tolist**() - преобразование массива в список.

Вот и всё, что можно было рассказать про массивы. Они используются редко, когда нужно достичь высокой скорости работы. В остальных случаях массивы можно заменить другими типами данных: [списками](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html), [кортежами](https://pythonworld.ru/tipy-dannyx-v-python/kortezhi-tuple.html), [строками](https://pythonworld.ru/tipy-dannyx-v-python/stroki-funkcii-i-metody-strok.html).



---

# **Lists (Списки)**  

### Чем отличаются списки от массивов

Списки и массивы позволяют хранить коллекции элементов, однако имеют ряд отличий.

Первое различие заключается в процессе их создания. Список формируется с использованием квадратных скобок [] и может содержать элементы различных типов данных, включая числа, строки, другие списки и даже функции. 

Допустим, нам нужно сделать список с числами, это будет выглядеть так. 

```
numbers = [1, 2, 3, 4, 5]
```

Чтобы создать массив, нам потребуется особый модуль array. При этом в нём могут содержаться исключительно элементы одного типа данных. 

### Почему иногда лучше все-таки массивы чем списки?

Раз списки более удобны, зачем нужны массивы? Оказывается, они компактнее, а также требуют меньше памяти. Поэтому актуальны в следующих ситуациях.

1. Вы собираетесь работать с приложениями, для которых необходим большой объём ресурсов.
2. Вам нужно выполнить низкоуровневую операцию.
3. В проекте используются математические вычисления.

Функциональность массивов и списков тоже различается. Списки в Python предлагают множество встроенных методов и функций, благодаря которым мы можем выполнять множество операций. С массивами функциональность ограничена, они не предлагают таких встроенных методов.

### Методы списков:

## `append(x)`

Добавляет элемент в конец списка.

[Подробнее](https://letpy.com/handbook/list-methods/append/)

## `clear()`

Удаляет из списка все имеющиеся в нём значения.

[Подробнее](https://letpy.com/handbook/list-methods/clear/)

## `copy()`

Возвращает копию списка.

[Подробнее](https://letpy.com/handbook/list-methods/copy/)

## `count(x)`

Возвращает количество вхождений значения в список.

[Подробнее](https://letpy.com/handbook/list-methods/count/)

## `extend(iterable)`

Дополняет список элементами из указанного объекта `iterable`.

[Подробнее](https://letpy.com/handbook/list-methods/extend/)

## `index(x[, start[, end]])`

Возвращает индекс первого элемента, со значением `х`.

[Подробнее](https://letpy.com/handbook/list-methods/index-method/)

## `insert(i, x)`

Вставляет указанный элемент перед указанным индексом в списке.

[Подробнее](https://letpy.com/handbook/list-methods/insert/)

## `pop([i])`

Возвращает элемент на указанной позиции, удаляя при этом его из списка.

[Подробнее](https://letpy.com/handbook/list-methods/pop/)

## `remove(x)`

Удаляет из списка указанный элемент.

[Подробнее](https://letpy.com/handbook/list-methods/remove/)

## `reverse()`

Перестраивает элементы списка в обратном порядке.

[Подробнее](https://letpy.com/handbook/list-methods/reverse/)

## `sort(key=None, reverse=False)`

Сортирует элементы списка.

[Подробнее](https://letpy.com/handbook/list-methods/sort/)

---

# Stacks (Стеки)

Стек (англ. stack — стопка) - ещё одна структура данных для хранения множества элементов но с особенностью: она на стопку тарелок. Если у вас есть такая стопка, убирать тарелки вы будете, начиная сверху. Таким образом, последняя тарелка, которую вы положили на стопку, будет убрана первой. Вероятно, вы слышали термин [LIFO](https://ru.wikipedia.org/wiki/LIFO) — Last In First Out («последним пришел, первым ушел»).

Эта структура не является нативной для языка Python, но её можно реализовать:

> [!ЧТО СДЕЛАТЬ]
>  # Реализуйте стек со следующими методами:
>  # 1. push(item), добавляющий элемент на вершину стека
>  # 2. pop(), удаляющий самый верхний элемент стека и возвращающий его.
>  # Если в стеке нет элементов, метод должен выбросить ошибку или вернуть null.
>  # Каждый метод должен иметь постоянную временную сложность.

А вот и код:

```
class Stack:
    def __init__(self):
        self.stack = []
        
    def push(self, item):
        self.stack.append(item)
        
    def pop(self):
        if len(self.stack) == 0:
            return None
        removed = self.stack.pop()
        return removed
```


---

# **Queues (Очереди)**  

Подобно стеку, очередь — это еще одна линейная структура данных, в которой элементы хранятся последовательно. Единственное существенное различие между стеком и очередью состоит в том, что вместо использования метода LIFO в Queue реализован метод [FIFO, который является сокращением от First in First Out](https://en.wikipedia.org/wiki/FIFO).  
Прекрасный реальный пример очереди: ряд людей, ожидающих у билетной кассы. Если приходит новый человек, он присоединяется к линии с конца, а не с начала — и человек, стоящий впереди, первым получит билет и, следовательно, покинет линию.  
Вот изображение очереди, содержащей четыре элемента данных (1, 2, 3 и 4), где 1 находится вверху и будет удалено первым:  
  
![](https://habrastorage.org/r/w1560/webt/1x/rs/yr/1xrsyryryhsien5gzdqpwphgbpo.png)  
  
За реализацию очереди в Python отвечает [Модуль `queue`](https://docs-python.ru/standart-library/modul-queue-python/ "Модуль queue, очереди в Python.") реализует очереди с несколькими производителями и несколькими потребителями. Это особенно полезно в потоковом программировании, когда информация должна безопасно обмениваться между несколькими потоками. [Класс `queue.Queue()`](https://docs-python.ru/standart-library/modul-queue-python/ochered-fifo/ "Класс Queue() модуля queue в Python.") в этом модуле реализует всю необходимую семантику блокировки.

Модуль реализует три типа очереди, которые отличаются только порядком, в котором извлекаются записи:

- В очереди FIFO первые добавленные задачи являются первыми извлеченными.
- В очереди LIFO самая последняя добавленная запись является первой извлеченной (работающей как стек).
- В очереди с приоритетами записи сохраняются отсортированными с использованием [модуля `heapq`](https://docs-python.ru/standart-library/modul-heapq-python/ "Модуль heapq, кучи в Python.") и сначала извлекается запись с наименьшим значением.

Внутренне эти три типа очередей используют блокировки для временного блокирования конкурирующих потоков, однако они не предназначены для обработки повторного входа в поток.

Кроме того, модуль реализует простой тип очереди FIFO - [`queue.SimpleQueue()`](https://docs-python.ru/standart-library/modul-queue-python/klass-simplequeue-modulja-queue/ "Класс SimpleQueue() модуля queue в Python."), специфическая реализация которого обеспечивает дополнительные гарантии в обмен на меньшую функциональность.

### Примеры использования модуля `queue`.

#### Очередь FIFO:

[Класс `queue.Queue()`](https://docs-python.ru/standart-library/modul-queue-python/ochered-fifo/ "Класс Queue() модуля queue в Python.") реализует базовый контейнер типа FIFO - "первым пришел - первым вышел". Элементы добавляются к одному концу очереди с помощью метода `put()`, а удаляются с другого конца с помощью метода `get()`.

```
import queue

q = queue.Queue()

for i in range(5):
    q.put(i)

while not q.empty():
    print(q.get(), end=' ')

# 0 1 2 3 4
```

#### Очередь LIFO:

В отличие от стандартной реализации очереди FIFO, в [`queue.LifoQueue()`](https://docs-python.ru/standart-library/modul-queue-python/ochered-lifo/ "Класс LifoQueue() модуля queue в Python.") используется порядок "последним пришел - первым вышел", который обычно связан со структурой данных стека.

```
import queue

q = queue.LifoQueue()

for i in range(5):
    q.put(i)

while not q.empty():
    print(q.get(), end=' ')
```


---
# Dequeue - Двусторонняя очередь в Python

[Класс `collections.deque()`](https://docs-python.ru/standart-library/modul-collections-python/klass-deque-modulja-collections/ "Класс deque() модуля collections в Python.") это обобщение стеков и очередей и представляет собой двустороннюю очередь. Двусторонняя очередь `deque()` поддерживает поточно-ориентированные, эффективные по памяти операции добавления и извлечения элементов последовательности с любой стороны с примерно одинаковой производительностью `O(1)` в любом направлении.

[Списки](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-list-spisok/ "Список list в Python.") поддерживают аналогичные операции, но они оптимизирован только для быстрых операций с [последовательностями](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tipy-posledovatelnostej/ "Типы последовательностей в Python.") фиксированной длины и требуют затрат `O(n)` на перемещение памяти для операций [`pop(0)`](https://docs-python.ru/tutorial/operatsii-izmenjaemymi-posledovatelnostjami-list-python/metod-list-pop/ "Метод list.pop() в Python, получение с удалением элемент списка.") и [`insert(0, v)`](https://docs-python.ru/tutorial/operatsii-izmenjaemymi-posledovatelnostjami-list-python/metod-list-insert/ "Метод list.insert() в Python, вставить элемент по индексу."), которые изменяют как размер, так и положение базового представления данных.

#### Синтаксис:


```python

import collections

dq = collections.deque([iterable[, maxlen]])

```

#### Параметры:

- `iterable` - [итерируемая последовательность](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tipy-posledovatelnostej/ "Типы последовательностей в Python."),
- `maxlen` - [`int`](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-int-tselye-chisla/ "Целые числа int в Python."), максимальное кол-во хранимых записей.

#### Возвращаемое значение:

- новый [объект `Deque`](https://docs-python.ru/standart-library/modul-collections-python/klass-deque-modulja-collections/#method).

#### Описание:

Класс [`deque()`](https://docs-python.ru/standart-library/modul-collections-python/klass-deque-modulja-collections/ "Класс deque() модуля collections в Python.") модуля [`collections`](https://docs-python.ru/standart-library/modul-collections-python/ "Модуль collections в Python, контейнерные типы данных.") возвращает новый объект [`deque()`](https://docs-python.ru/standart-library/modul-collections-python/klass-deque-modulja-collections/ "Класс deque() модуля collections в Python."), инициализированный слева направо данными из [итерируемой](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-iterator-iterator/ "Итератор Iterator, протокол итератора в Python.") последовательности `iterable`.

При создании объекта очереди класс использует метод [`dq.append()`](https://docs-python.ru/standart-library/modul-collections-python/klass-deque-modulja-collections/#dq.append) для добавления элементов из [итерации](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-iterator-iterator/ "Итератор Iterator, протокол итератора в Python.") `iterable`. Если итерация не указана, новая очередь `deque()` будет пуста.

```python

from collections import deque
dq = deque('ghi')
dq
deque(['g', 'h', 'i'])

```

Если аргумент `maxlen` не указан или равен `None`, количество хранимых записей в объекте `deque()` может увеличиваться до произвольной длины. В противном случае, объект `deque()` ограничивает количество хранимых элементов в своем контейнере максимальной длиной `maxlen`.

При добавлении новых элементов, когда заполнение очереди `deque()` становится больше значения `maxlen`, избыточное количество элементов удаляется/сбрасывается с противоположного конца. Заполнение очереди на определенную длину обеспечивают функциональность, аналогичную команде bash `tail` в Unix. Такое поведение полезно для отслеживания транзакций и других пулов данных, где интерес представляют только самые последние изменения или действия.

### Объект `Deque`, атрибуты и методы:

#### _`Deque.append(x)`_:

Метод `Deque.append()` добавляет `x` к правой стороне (в конец) контейнера `deque()`.

```python

dq.append('j')
dq

# Вывод: deque(['g', 'h', 'i', 'j'])

```

#### _`Deque.appendleft(x)`_:

Метод `Deque.appendleft()` добавляет `x` к левой стороне (в начало) контейнера `deque()`.

```python

dq.appendleft('f')
dq
>>> deque(['f', 'g', 'h', 'i', 'j'])

```

#### _`Deque.copy()`_:

Метод `Deque.copy()` создает мелкую копию контейнера `deque()`.

```python

cp_dq = dq.copy()

cp_dq
>>> deque(['f', 'g', 'h', 'i', 'j'])

```

#### _`Deque.clear()`_:

Метод `Deque.clear()` удаляет все элементы из контейнера `deque()`, оставляя его длиной 0.

```python
cp_dq.clear()
cp_dq
>>> deque([])
dq
>>> deque(['f', 'g', 'h', 'i', 'j'])
```

#### _`Deque.count(x)`_:

Метод `Deque.count()` подсчитывает количество элементов контейнера `deque()`, равное значению `x`.

>>> dq.append('g')
>>> dq.count('g')
#2
>>> dq
#deque(['f', 'g', 'h', 'i', 'j', 'g'])

#### _`Deque.extend(iterable)`_:

Метод `Deque.extend()` расширяет правую сторону (с конца) контейнера `deque()`, добавляя элементы из [итерируемого](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-iterator-iterator/ "Итератор Iterator, протокол итератора в Python.") аргумента `iterable`.

>>> dq.extend('jkl')
>>> dq
deque(['f', 'g', 'h', 'i', 'j', 'g', 'j', 'k', 'l'])

#### _`Deque.extendleft(iterable)`_:

Метод `Deque.extendleft()` расширяет левую сторону (с начала) контейнера `deque()`, добавляя элементы из [итерируемого](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-iterator-iterator/ "Итератор Iterator, протокол итератора в Python.") аргумента `iterable`.

**Обратите внимание**, что ряд последовательных добавлений в начало контейнера приводит к изменению порядка элементов в аргументе `iterable`.

>>> dq.extendleft('ab')
>>> dq
deque(['b', 'a', 'f', 'g', 'h', 'i', 'j', 'g', 'j', 'k', 'l'])

#### _`Deque.index(x[, start[, stop]])`_:

Метод `Deque.index()` вернет позицию ([индекс](https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/izvlechenie-elementa-sequence-indeksu/ "Получение значения элемента по индексу sequence[i] в Python.")) первого совпадения значения аргумента `x` в контейнере `deque()`, расположенного после необязательного аргумента `start` и до необязательного аргумента `stop`.

Вызывает [исключение `ValueError`](https://docs-python.ru/tutorial/vstroennye-iskljuchenija-interpretator-python/vstroennye-iskljuchenija/ "Исключения наследуемые от Exception в Python."), если значения аргумента `x` не найдено.

>>> dq.index('g', 2)
3
>>> dq.index('b', 2)
Traceback (most recent call last):

ValueError: 'b' is not in deque

#### _`Deque.insert(i, x)`_:

Метод `Deque.insert()` вставляет значение аргумента `x` в позицию `i` контейнера `deque()`.

Если вставка значение аргумента `x` приведет к тому, что ограниченный контейнер `deque()` выйдет за пределы `maxlen`, будет вызвано [исключение `IndexError`](https://docs-python.ru/tutorial/vstroennye-iskljuchenija-interpretator-python/vstroennye-iskljuchenija/ "Исключения наследуемые от Exception в Python.").

>>> dq.insert(2, 'c')
>>> dq
deque(['b', 'a', 'c', 'f', 'g', 'h', 'i', 'j', 'g', 'j', 'k', 'l'])

#### _`Deque.pop()`_:

Метод `Deque.pop()` удаляет и возвращает элемент с правой стороны (с конца) контейнера `deque()`. Если элементы отсутствуют, возникает [ошибка `IndexError`](https://docs-python.ru/tutorial/vstroennye-iskljuchenija-interpretator-python/vstroennye-iskljuchenija/ "Исключения наследуемые от Exception в Python.").

>>> dq.pop()
'i'

#### _`Deque.popleft()`_:

Метод `Deque.popleft()` удаляет и возвращает элемент с левой стороны (с начала) контейнера `deque()`. Если элементы отсутствуют, возникает [ошибка `IndexError`](https://docs-python.ru/tutorial/vstroennye-iskljuchenija-interpretator-python/vstroennye-iskljuchenija/ "Исключения наследуемые от Exception в Python.").

>>> dq.popleft()
'b'

#### _`Deque.remove(value)`_:

Метод `Deque.remove()` удаляет первое вхождение значения `value` в контейнер `deque()`. Если значение `value` не найдено, возникает [ошибка `IndexError`](https://docs-python.ru/tutorial/vstroennye-iskljuchenija-interpretator-python/vstroennye-iskljuchenija/ "Исключения наследуемые от Exception в Python.").

>>> dq.remove('g')
>>> dq
deque(['a', 'c', 'f', 'h', 'i', 'j', 'g', 'j', 'k'])

#### _`Deque.reverse()`_:

Метод `Deque.reverse()` разворачивает элементы контейнера `deque()` на месте и возвращает `None`.

>>> dq.reverse()
>>> dq
deque(['k', 'j', 'g', 'j', 'i', 'h', 'f', 'c', 'a'])

#### _`Deque.rotate(n=1)`_:

Метод `Deque.rotate()` разворачивает контейнер `deque()` на `n` шагов вправо. Если аргумент `n` имеет отрицательное значение, то разворачивает контейнер налево.

Когда контейнер не пуст, вращение на один шаг вправо эквивалентно `dq.appendleft(d.pop())`, а вращение на один шаг влево эквивалентно `dq.append(d.popleft())`.

>>> dq.rotate(2)
>>> dq
deque(['c', 'a', 'k', 'j', 'g', 'j', 'i', 'h', 'f'])
>>> dq.rotate(-4)
>>> dq
deque(['g', 'j', 'i', 'h', 'f', 'c', 'a', 'k', 'j'])

#### _`Deque.maxlen`_:

Свойство `Deque.maxlen()` возвращает максимальный размер `maxlen` контейнера `deque()`, если параметр `maxlen` не задан, то возвращает `None`.


---
  
# **Связанный список (Linked List)**  

Python очень удобный и многогранный язык, но по умолчанию не имеет такой структуры данных как связный список или LinkedList.

Связанный список — это еще одна важная линейная структура данных, которая на первый взгляд может выглядеть аналогично массивам, но отличается распределением памяти, внутренней структурой и тем, как выполняются основные операции вставки и удаления.  
  
Связанный список подобен цепочке узлов, где каждый узел содержит такую информацию, как данные, и указатель на последующий узел в цепочке. Есть указатель заголовка, который указывает на первый элемент связанного списка, и если список пуст, то он просто указывает на ноль или ничего.  
  
Связанные списки используются для реализации файловых систем, хеш-таблиц и списков смежности.  
  
Вот визуальное представление внутренней структуры связанного списка:  
  
![](https://habrastorage.org/r/w1560/webt/fl/3i/ze/fl3izeslba8w1wzeyg1tnrby7ug.png)  
  
Ниже приведены типы связанных списков:  

- Односвязный список (однонаправленный)
- Двусвязный список (двунаправленный)

Основные операции над связанным списком  
ВставитьВКонец (InsertAtEnd) — вставляет элемент в конец связанного списка.  
ВставитьВНачало (InsertAtHead) — вставляет элемент в начало связанного списка.  
Удалить (Delete) — удаляет данный элемент из связанного списка.  
УдалитьВНачале (DeleteAtHead) — удаляет первый элемент связанного списка.  
Search (Поиск) — возвращает найденный элемент из связанного списка.  
Пустой? (IsEmpty) — возвращает истина (true), если связанный список пуст.  

Можно реализовать такую структура на Python следующим образом:

```python

  def removeBox(self,rmcat):
    headcat = self.head

    if headcat is not None:
      if headcat.cat==rmcat:
        self.head = headcat.nextcat
        headcat = None
        return
        
    while headcat is not None:
      if headcat.cat==rmcat:
        break
        
      lastcat = headcat
      headcat = headcat.nextcat
      
    if headcat == None:
      return
      
    lastcat.nextcat = headcat.nextcat
    headcat = None
    
```


---
# **Graphs (Графы)**  

Опять же в Python нет нативно данной структуры данных, но есть библиотеки для работы с ними:

- [NetworkX](https://networkx.org/) для общего анализа графов;
- [PyVis](https://pyvis.readthedocs.io/en/latest/) для интерактивной визуализации графов прямо в браузере;
- [PyG](https://www.pyg.org/) и [DGL](https://www.dgl.ai/) для решения различных задач в области машинного обучения на графах.

Графы — это набор узлов, которые связаны друг с другом в форме сети. Узлы также называются вершинами. Пара (x, y) называется ребром, что указывает на то, что вершина x связана с вершиной y. Ребро может содержать вес / стоимость, показывая, сколько затрат требуется для перехода от вершины x к y.  
  
![](https://habrastorage.org/r/w1560/webt/6h/nw/g-/6hnwg-sgikrn3gmftsuwnfklkcs.png)  
  
Типы графов:  

- Undirected Graph (ненаправленные)
- Directed Graph (направленные, т.е. векторы)


---
  
# Trees (Деревья)

В Pyhton'е они не выделяются как отдельные структуры данных, но как пример вложенные списки, сложенные кортежи, словари - древовидные структуры.

```
() # Пустое дерево
(3, 2, (3, 8), ((8), 3))
(1, None, ((3)), (5, 'string', (False, (3), {"key": "value"})))
```

Дерево — это иерархическая структура данных, состоящая из вершин (узлов) и ребер, которые их соединяют. Деревья похожи на графы, но ключевой момент, который отличает дерево от графа, состоит в том, что цикл не может существовать в дереве. Дерево — это разорваный граф.  
  
Деревья широко используются в искусственном интеллекте и сложных алгоритмах, чтобы обеспечить эффективный механизм хранения для алгоритмов решения проблемы.  
  
Вот изображение простого дерева и основные термины, используемые в древовидной структуре данных:  
  
![](https://habrastorage.org/r/w1560/webt/w4/ic/iv/w4icivyghqug8j9nxyer2xuvwxi.png)  
  
Имеются типы деревьев:  
  

- N-ое дерево
- Сбалансированное дерево (Balanced Tree)
- Бинарное дерево (Binary Tree)
- Бинарное поисковое дерево (Binary Search Tree)
- AVL дерево
- Красно-черное дерево (Red Black Tree)
- 2–3 дерево


---

# Очередности (Trie)

Как таковой структуры в Python нет, но можно реализовать

Очередности, также известные как деревья с префиксами (Prefix Trees), представляют собой древовидную структуру данных, которая оказывается достаточно эффективной для решения проблем, связанных со строками. Они обеспечивают быстрый поиск и, в основном, используются для поиска слов в словаре, автоматического предложения в поисковой системе и даже для IP-маршрутизации.  
  
Вот иллюстрация того, как три слова «top», «thus», и «their» хранятся в Очередности:  
  
![](https://habrastorage.org/r/w1560/webt/11/os/cj/11oscjph-dhzoqncmzbq6dxb1mo.png)  
  
Слова хранятся сверху вниз, где зеленые узлы “p”, “s” и “r” указывают на конец “top”, “thus”, и “their” соответственно.  
  
---  
# Hash Table (Хеш-таблица) в Python ИЛИ Словари (Dictionary)

Ассоциативный массив — абстрактный тип данных, с помощью которого хранятся пары «ключ-значение». В разных языках ему соответствуют разные типы данных. В Python — это Dictionary, в других языках:

Ассоциативные массивы популярны в прикладном программировании. С их помощью удобно представлять составные данные, содержащие множество различных параметров.

В обычном индексированном массиве значения расположены по индексам, а значит его можно положить в память «как есть». С ассоциативными массивами все работает по-другому. У них нет индексов, которые бы могли определить порядок — значит, и нет простого способа добраться до значений.

Для реализации ассоциативных массивов часто используют специальную структуру данных — **хеш-таблицу**.

Хеширование — это процесс, используемый для уникальной идентификации объектов и сохранения каждого объекта по некоторому предварительно рассчитанному уникальному индексу, называемому его «ключом». Таким образом, объект хранится в форме пары «ключ-значение», а коллекция таких элементов называется «словарь». Каждый объект может быть найден с помощью этого ключа.  
  
Существуют разные структуры данных, основанные на хешировании, но наиболее часто используемой структурой данных является хеш-таблица. Хэш-таблица используется, когда вам нужно получить доступ к элементам с помощью ключа, и вы можете определить полезное значение ключа.  
  
Хеш-таблицы обычно реализуются с использованием массивов.  
  
Производительность хеширования структуры данных зависит от этих трех факторов:  

- Хэш-функция
- Размер хеш-таблицы
- Метод обработки столкновений

Вот иллюстрация того, как хэш отображается в массиве. Индекс этого массива вычисляется с помощью хэш-функции.  
  
![](https://habrastorage.org/r/w1560/webt/r4/jk/qj/r4jkqjrkjobsio3r3eq02ebxstw.png)

## Что такое хеширование

Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс обычного массива. Для получения индекса из ключа нужно выполнить два действия:

- Найти хеш, то есть хешировать ключ
- Привести ключ к индексу — например, через остаток от деления

**Хеширование** — операция, которая преобразует любые входные данные в строку или число фиксированной длины. Функция, реализующая алгоритм преобразования, называется **«хеш-функцией»**. При этом результат хеширования называют **«хешем»** или **«хеш-суммой»**.

Наиболее известны CRC32, MD5, SHA и много других типов хеширования:

```
# В Python есть библиотека zlib, содержащая алгоритм хеширования crc32
# Этот алгоритм удобен для наглядности
import zlib

# Любые данные, которые мы хотим хешировать, представляются в виде байтовой строки
data = b'Hello, world!'
hash = zlib.crc32(data)

# Хеш всегда одинаковый для одних и тех же данных
print(hash) # => 3957769958
```

С хешированием мы встречаемся в разработке часто. Например, идентификатор коммита в git `0481e0692e2501192d67d7da506c6e70ba41e913` — это хеш, полученный в результате хеширования данных коммита.

При записи в хеш-таблицу сначала нужно получить хеш. Затем его можно преобразовать в индекс массива — например, вычислить остаток от деления:

```
# Это делается для того, чтобы индексы не были слишком большими
# Чем больше размер массива, тем больше памяти он занимает
index = abs(hash) % 1000 # по модулю
print(index) # => 958
```

![hash.jpg](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjkzZWQ0Mzk5N2Y5M2JjNjIwNjQ4NTNlMDU1MGRkNzQwLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=60c1b811a4ef50cf51225ec1ebeb88e44232d845b917a1a2fa393f7713580477)

### Как хеширование работает изнутри

Рассмотрим, как работает добавление нового значения в ассоциативный массив. Напомним, в Python он представлен типом данных Dictionary. Напишем такой код:

```
data = {}
data['key'] = 'value'
```

Такой простой код запускает целый сложный процесс. Для простоты рассмотрим его на Python, хотя в реальности все это происходит на более низком уровне. Опишем процесс хеширования без деталей и с упрощениями.

1. Мы создаем ассоциативный массив. Внутри интерпретатора происходит инициализация индексированного массива:
    
    ```
    internal = []
    ```
    
2. Далее мы присваиваем значение:
    
    ```
    data['key'] = 'value'
    ```
    
3. Затем интерпретатор хеширует ключ. Результатом хеширования становится число:
    
    ```
    hash = zlib.crc32(b'key')
    ```
    
4. Далее интерпретатор берет число из предыдущего шага и преобразует его в индекс массива:
    
    ```
    index = abs(hash) % 1000
    ```
    
5. В конце интерпретатор ищет по индексу значение внутреннего индексированного массива и записывает его в еще один массив. Первым элементом нового массива становится ключ `'key'`, а вторым — значение `'value'`:
    
    ```
    internal[index] = ['key', 'value']
    ```
    

Теперь посмотрим, как работает чтение данных:

```
data = {}
data['key'] = 'value'
print(data['key']) # => "value"
```

Разберем, как этот код работает изнутри.

1. Интерпретатор хеширует ключ. Результатом хеширования становится число:
    
    ```
    hash = zlib.crc32(b'key')
    ```
    
2. Число, полученное на предыдущем шаге, преобразуется в индекс массива:
    
    ```
    index = abs(hash % 1000)
    ```
    
3. Если индекс существует, то интерпретатор извлекает массив и возвращает его наружу:
    
    ```
    return internal[index] # ['key', 'value']
    ```
    

## Коллизии

> [!ВАЖНО]
> ПОДРОБНО ПРО КОЛЛИЗИИ И КАК БОРОТЬСЯ В ДОП ВОПРОСАХ

Ключом в ассоциативном массиве может быть абсолютно любая строка, любой длины и содержания. Но здесь есть одно противоречие:

- Все возможные ключи — это бесконечное множество
- В качестве результата хеш-функция выдает строку фиксированной длины, то есть все выходные значения — это конечное множество

Из этого факта следует, что не для всех входных данных найдется уникальный хеш. На каком-то этапе могут появиться дубли: под одним хешем будут лежать несколько разных значений.

Такую ситуацию принято называть **коллизией**. Есть несколько способов [разрешения коллизий](https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0#%D0%A0%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BB%D0%BB%D0%B8%D0%B7%D0%B8%D0%B9). Каждому способу соответствует свой тип хеш-таблицы:

```
# Пример коллизии
# Хеш-функция возвращает одинаковый хеш для разных строчных данных
zlib.crc32(b'aaaaa0.462031558722291') # 1938556049
zlib.crc32(b'aaaaa0.0585754039730588') # 1938556049
```

Простейший способ разрешения коллизий — это **открытая адресация**. Она предполагает последовательное перемещение по слотам хеш-таблицы в поисках первого свободного слота, куда значение будет записано.