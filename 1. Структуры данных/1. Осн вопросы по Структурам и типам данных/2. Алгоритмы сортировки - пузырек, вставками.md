

# Алгоритм сортировки вставками



**Сортировка вставками** (**Insertion Sort**) простой алгоритм, часто используется при изучение компьютерных наук и обычно, является одним из первых алгоритмов сортировки, с которым знакомя учеников. Он интуитивно понятен и прост в реализации, но он очень медленный для больших массивов и поэтому почти никогда не используется для сортировки реальных данных.

**Insertion Sort** является _**stable**_ и _**in-place**_ алгоритмом, который действительно хорошо работает только для почти отсортированных или небольших массивов.

Что значит _**stable**_ и _**in-place**_:

- **in-place**: Требует небольшого постоянного дополнительного пространства памяти (независимо от входного размера коллекции),он перезаписывает исходные ячейки памяти элементов в коллекции.
- **stable**: Алгоритм поддерживает относительный порядок равных объектов из исходного массива. Другими словами, скажем, база данных сотрудников вашей компании возвращает двух сотрудников «Дейв Уотсон» и «Дейв Браун» в указанном порядке. Если бы вы отсортировали их по (общему) имени, _stable_ алгоритм гарантирует, что этот порядок останется неизменным.

Так же при сортировке вставками вам не обязательно нужно иметь весь массив заранее перед сортировкой. Алгоритм может получать по одному элементу в процессе сортировки. Это очень удобно, если нам нужно добавлять больше элементов во время сортировки – алгоритм будет вставлять новый элемент элемент в нужное место без «повторного выполнения» сортировки всего массива.

Сортировка вставками может используется на практике из-за ее эффективности для небольших (~ 10 элементов) наборов данных. Но мы поговорим об этом позже.

### Как работает сортировка вставками

Массив разбивается на «отсортированный» подмассив и «несортированный» подмассив. В начале отсортированный подмассив содержит только первый элемент нашего исходного массива.

Первый элемент в несортированном массиве оценивается так, что мы можем вставить его на свое место в отсортированном подмассиве.

Вставка выполняется путем перемещения всех элементов которые больше, чем новый элемент, на одну позицию вправо.

Это продолжается, пока весь наш массив не будет отсортирован.

Имейте в виду, однако, что когда мы говорим, что элемент больше или меньше, чем другой элемент – это не обязательно означает большие или меньшие целые числа.

Мы можем определить слова «**больше**» и «**меньше**», как нам нравится при использовании пользовательских объектов. Например, точка **A** может быть «больше», чем точка **B**, если она находится дальше от центра системы координат.

Мы помечаем отсортированный подмассив **жирными** числами и используем следующий массив для иллюстрации алгоритма:

8, 5, 3, 11, 9

Первым шагом было бы «_добавить_» 8 в наш отсортированный подмассив.

**8**, 5, 3, 11, 9

Теперь рассмотрим первый **несортированный** элемент – 5. Мы сохраняем это значение в отдельной переменной, например, **current**, для сохранности. 5 меньше 8. Мы перемещаем 8 на одно место вправо, фактически перезаписывая 5, которые было там ранее сохранено (отсюда и отдельная переменная для безопасного хранения):

**8**, _8_, 3, 11, 9 (`current` = 5)

5 меньше всех элементов в нашем отсортированном подмассиве, поэтому мы вставляем его на первую позицию:

**5**, **8**, 3, 11, 9

Далее мы смотрим на номер 4. Мы сохраняем это значение в **current**. 4 меньше 8, поэтому мы перемещаем 8 вправо и делаем то же самое с 5.

**5**, **5**, **8**, 11, 9 (`current` = 3)

Мы снова столкнулись с элементом, меньшим, чем весь наш отсортированный подмассив, поэтому мы поместили его на первую позицию:

**3**, **5**, **8**, 11, 9

10 больше, чем наш самый правый элемент в отсортированном подмассиве, и поэтому больше, чем любой из элементов слева от 8. Поэтому мы просто переходим к следующему элементу:

**3**, **5**, **8**, **11**, 9

9 меньше 10, поэтому мы переместимся на 10 вправо:

**3**, **5**, **8**, **11**, _10_ (`current` = 9)

Однако 9 больше 8, поэтому мы просто вставляем 9 сразу после 8.

**3**, **5**, **8**, **9**, **11**

### Реализация

Как мы уже упоминали, **Insertion Sort** довольно легко реализовать. Мы реализуем это сначала на простом массиве целых чисел, а затем на некоторых пользовательских объектах.

На практике гораздо более вероятно, что вы будете работать с объектами и сортировать их по определенным критериям.

#### Сортировка массивов

```python

def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >=0 and key < arr[j] :
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key 
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print ("Sorted array is:")
for i in range(len(arr)):
    print arr[i]
    
```

Давайте заполним простой массив и отсортируем его:

```python

array = [4, 22, 41, 40, 27, 31, 36, 1, 42, 39, 14, 9, 3, 6, 34, 9, 21, 4, 29, 49]
insertion_sort(array)
print("sorted: " + str(array))

```

Вывод:

```python

sorted: [1, 3, 4, 4, 6, 9, 9, 14, 21, 22, 27, 29, 31, 34, 36, 39, 40, 41, 42, 49]

```

### Анализ сложности

Сортировка вставками может показаться медленным алгоритмом, и, действительно, в большинстве случаев он слишком медленный для любого практического использования с его временной сложностью **_O(n2)_.** Однако, как мы уже упоминали, он очень эффективный для небольших массивов и почти отсортированных массивов.

Это делает сортировку вставками очень актуальной для использования в сочетании с алгоритмами, которые хорошо работают с большими наборами данных.

Например, в Java используется [быстрая сортировка](https://webdevblog.ru/bystraya-sortirovka-v-python/) Dual Pivot в качестве основного алгоритма сортировки, но так же используется сортировка вставками всякий раз, когда массив (или коллекция, созданная быстрой сортировкой) содержит менее 7 элементов.

Еще одно место, где Insertion Sort оставил свой след, – это очень популярный алгоритм **Shell Sort**. **Shell Sort** работает, вызывая Insertion Sort для сортировки пар элементов далеко друг от друга, затем постепенно уменьшая разрыв между элементами для сравнения.

---
---


# Алгоритм сортировки пузырек

Сортировка пузырьком - это метод сортировки массивов и списков путем последовательного сравнения соседних элементов и их обмена, если предшествующий оказывается больше последующего (при сортировке по возрастанию).

В процессе выполнения данного алгоритма элементы с большими значениями оказываются в конце списка, а элементы с меньшими значениями постепенно перемещаются по направлению к началу списка. Образно говоря, тяжелые элементы падают на дно, а легкие медленно всплывают подобно пузырькам воздуха. При этом в начале сортировки отсортированным становится конец списка, а не его начало.

В сортировке методом пузырька количество итераций внешнего цикла определяется длинной списка минус единица, так как когда второй элемент становится на свое место, то первый уже однозначно минимальный и не требует сортировки.

Количество итераций внутреннего цикла зависит от номера итерации внешнего цикла, так как конец списка уже отсортирован, и выполнять проход по этим элементам смысла нет.

Пусть имеется список из пяти элементов

```
[6, 12, 4, 3, 8]
```

За первую итерацию внешнего цикла число 12 переместится в конец. Для этого потребуется 4 сравнения во внутреннем цикле:

```
- 6 > 12? Нет
- 12 > 4? Да. Меняем местами
- 12 > 3? Да. Меняем местами
- 12 > 8? Да. Меняем местами
```

Результат: 

[6, 4, 3, 8, 12]

За вторую итерацию внешнего цикла число 8 переместиться на предпоследнее место. Для этого потребуется 3 сравнения:

- 6 > 4? Да. Меняем местами
- 6 > 3? Да. Меняем местами
- 6 > 8? Нет

Результат: 

```
[4, 3, 6, 8, 12]
```

На третьей итерации внешнего цикла исключаются два последних элемента. Количество итераций внутреннего цикла равно двум:

```
- 4 > 3? Да. Меняем местами
- 4 > 6? Нет```
```

Результат: 

```
[3, 4, 6, 8, 12]
```

На четвертой итерации внешнего цикла осталось сравнить только первые два элемента, поэтому количество итераций внутреннего равно единице:

```
- 3 > 4? Нет
```

Результат: 

```
[3, 4, 6, 8, 12]
```

**Реализация сортировки пузырьком на языке программирования Python с помощью циклов `for`**

```python

from random import randint

N = 10  # количество элементов в списке
a = []
for i in range(N):
    a.append(randint(1, 99))
print(a)  # вывод исходного неотсортированного списка

# Сама сортировка методом "пузырька"
for i in range(N-1):
    for j in range(N-1-i):
        if a[j] > a[j+1]:
            a[j], a[j+1] = a[j+1], a[j]

print(a)  # вывод отсортированного списка

```

Пример выполнения кода:

```
[63, 80, 62, 69, 71, 37, 12, 90, 19, 67]
[12, 19, 37, 62, 63, 67, 69, 71, 80, 90]
```

Для сортировки по убыванию достаточно изменить знак операции сравнения при `if` на обратный.