## Какие существуют типы данных в Python?

- Числовые типы данных: `int`, `float`, `complex`, используются для представления чисел.
- Тип данных String: `str`, используется для представления текстовой информации.
- Последовательности: `list`, `tuple`, `range` (список, кортеж, диапазон), используются для хранения упорядоченных коллекций объектов.
- Двоичные: `bytes`, `bytearray`, `memoryview`, используются для хранения двоичных данных, таких как изображения и звук.
- Сопоставления: `dict`, используется для хранения данных в виде пар ключ-значение.
- Логический: `bool`, используется для представления логических значений True и False.
- Множества: `set`, `frozenset`, используются для хранения уникальных элементов в неупорядоченном виде.

---

## Числовые типы данных

Числовой тип данных **Python** используется для хранения числовых значений, например:

- `int` – содержит целые числа со знаком неограниченной длины.
- **long – содержит длинные целые числа (существует в Python 2.x, убран Python 3.x).**
- `float` – содержит числа с плавающей точкой с точностью до 15 десятичных знаков и может достигать до 53 бит.
- `complex` – содержит комплексные числа.

Числовые типы могут использоваться для математических вычислений и операций, таких как сложение, вычитание, умножение и деление.

В **Python** есть функция `type()`, которая возвращает тип данных переменной. Тип данных может изменяться в процессе работы программы, например, переменная может сначала содержать целое число, а затем строку.

**Пример:**

main.py

```python
# целочисленное число
a = 10
print('Тип переменной, имеющей значение', a, 'это', type(a))
# число с плавающей точкой
b = 5.1234
print('Тип переменной, имеющей значение', b, 'это', type(b))
# комплексное число
c = 500 + 3j
print('Тип переменной, имеющей значение', c, 'это', type(c))
```

**Результат:**

Терминал

```sh
>>> Тип переменной, имеющей значение 10 это <class 'int'>
>>> Тип переменной, имеющей значение 5.1234 это <class 'float'>
>>> Тип переменной, имеющей значение (500+3j) это <class 'complex'>
```
---
## Строковой тип данных

Строка (String) — это последовательность символов. **Python** поддерживает символы **Unicode**. Обычно строки представляются в одинарных или двойных кавычках.

Строки в **Python** являются неизменяемыми (**immutable**), то есть после создания строки нельзя изменить ее содержимое. Если нужно изменить строку, необходимо создать новую строку с нужным содержимым.

Строки в **Python** поддерживают множество методов, таких как методы для поиска подстрок, замены символов, разбиения строк на части, удаления пробельных символов и многие другие.

Также в **Python** есть так называемые "сырые строки" (**raw strings**), которые позволяют включать специальные символы (например, обратный слеш) без необходимости экранирования.

**Пример:**

main.py

```python
# Строка
s = "Пример строки"
print('Тип переменной, имеющей значение', s, 'это', type(s))

# Строка с использованием одинарных кавычек
s1 = 'Еще один пример строки'
print('Тип переменной, имеющей значение', s1, 'это', type(s1))

# Пустая строка
s2 = ""
print('Тип переменной, имеющей значение', s2, 'это', type(s2))

# строка, содержащая цифры и символы
s3 = "123abc!?"
print('Тип переменной, имеющей значение', s3, 'это', type(s3))
```

**Результат:**

Терминал

```sh
>>> Тип переменной, имеющей значение Пример строки это <class 'str'>
>>> Тип переменной, имеющей значение Еще один пример строки это <class 'str'>
>>> Тип переменной, имеющей значение  это <class 'str'>
>>> Тип переменной, имеющей значение 123abc!? это <class 'str'>
```
---
## Тип данных последовательностей

Типы данных последовательностей в **Python** позволяют хранить упорядоченные коллекции объектов.

- Список (**list**) - это упорядоченная коллекция объектов, которая может содержать элементы разных типов. Элементы списка могут изменяться, добавляться или удаляться во время выполнения программы.
- Кортеж (**tuple**) - это упорядоченная коллекция объектов, которая также может содержать элементы разных типов. Кортежи отличаются от списков тем, что элементы в них не могут быть изменены после создания.
- Диапазон (**range**) - это тип данных, который представляет последовательность чисел. Обычно он используется в циклах for для указания количества итераций.

**Пример:**

main.py

```python
# создание списка
my_list = [1, 'hello', True]
print('Тип переменной my_list это', type(my_list))

# создание кортежа
my_tuple = (1, 'hello', True)
print('Тип переменной my_tuple это', type(my_tuple))

# создание диапазона
my_range = range(5)
print('Тип переменной my_range это', type(my_range))
```

**Результат:**

Терминал

```sh
>>> Тип переменной my_list это <class 'list'>
>>> Тип переменной my_tuple это <class 'tuple'>
>>> Тип переменной my_range это <class 'range'>
```
---
# Так как типы данных последовательности встречаются вообще постоянно, давайте поговорим про них более подробно\

## List (список)

Списки в Python - упорядоченные изменяемые коллекции объектов произвольных типов (почти как массив, но типы могут отличаться).

Чтобы использовать списки, их нужно создать. Создать список можно несколькими способами. Например, можно обработать любой итерируемый объект (например, [строку](https://pythonworld.ru/tipy-dannyx-v-python/stroki-literaly-strok.html)) встроенной функцией **list**:

```
in:    list('список')
out:   ['с', 'п', 'и', 'с', 'о', 'к']
```

```
>>> s = []  # Пустой список
>>> l = ['s', 'p', ['isok'], 2] ## вложенный список
>>> s
[]
>>> l
['s', 'p', ['isok'], 2]
```

Как видно из примера, список может содержать любое количество любых объектов (в том числе и вложенные списки), или не содержать ничего.

И еще один способ создать список - это **генераторы списков**. Генератор списков - способ построить новый список, применяя выражение к каждому элементу последовательности. Генераторы списков очень похожи на цикл [for](https://pythonworld.ru/osnovy/cikly-for-i-while-operatory-break-i-continue-volshebnoe-slovo-else.html).

```
>>> c = [c * 3 for c in 'list']
>>> c
['lll', 'iii', 'sss', 'ttt']
```

Возможна и более сложная конструкция генератора списков:

```
>>> c = [c * 3 for c in 'list' if c != 'i']
>>> c
['lll', 'sss', 'ttt']
>>> c = [c + d for c in 'list' if c != 'i' for d in 'spam' if d != 'a']
>>> c
['ls', 'lp', 'lm', 'ss', 'sp', 'sm', 'ts', 'tp', 'tm']
```

Но в сложных случаях лучше пользоваться обычным циклом for для генерации списков.

## Функции и методы списков

Создать создали, теперь нужно со списком что-то делать. Для списков доступны основные [встроенные функции](https://pythonworld.ru/osnovy/vstroennye-funkcii.html), а также методы списков.

## Таблица "методы списков"

|Метод|Что делает|
|---|---|
|**list.append**(x)|Добавляет элемент в конец списка|
|**list.extend**(L)|Расширяет список list, добавляя в конец все элементы списка L|
|**list.insert**(i, x)|Вставляет на i-ый элемент значение x|
|**list.remove**(x)|Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует|
|**list.pop**([i])|Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент|
|**list.index**(x, [start [, end]])|Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)|
|**list.count**(x)|Возвращает количество элементов со значением x|
|**list.sort**([key=функция])|Сортирует список на основе функции|
|**list.reverse**()|Разворачивает список|
|**list.copy**()|Поверхностная копия списка|
|**list.clear**()|Очищает список|

Нужно отметить, что методы списков, в отличие от [строковых методов](https://pythonworld.ru/tipy-dannyx-v-python/stroki-funkcii-i-metody-strok.html), изменяют сам список, а потому результат выполнения не нужно записывать в эту переменную.


```
>>> l = [1, 2, 3, 5, 7]
>>> l.sort()
>>> l
[1, 2, 3, 5, 7]
>>> l = l.sort()
>>> print(l)
None
```

---
## Сразу тут же должен быть доп. вопрос про генераторы:

Допустим, у вас есть файл, который весит десяток гигабайт. Из него нужно выбрать и обработать строки, подходящие под какое-то условие, а то и сравнить со строками другого большого файла.

Другой пример: нужно проанализировать практически бесконечный поток данных. Это могут быть, например, показания счётчиков, биржевые котировки, сетевой трафик.

А может, нужно создать поток данных самостоятельно: рассчитать комбинаторную структуру для определения вероятности какого-то события, математическую последовательность или последовательность случайных чисел.

Что делать? Хранить такие объёмы данных в компьютере нереально: они не поместятся в оперативную память — а некоторые и на жёсткий диск. Выход один — обрабатывать информацию небольшими порциями, чтобы не вызывать переполнения памяти. В Python на этот случай есть специальный инструмент — генераторы.

## Что такое генератор и как он работает?

- Генератор — это объект, который сразу при создании не вычисляет значения всех своих элементов.
- Он хранит в памяти только последний вычисленный элемент, правило перехода к следующему и условие, при котором выполнение прерывается.
- Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется.

Этим генераторы отличаются от списков — те хранят в памяти все свои элементы, и удалить их можно только программно. Вычисления с помощью генераторов называются ленивыми, они экономят память.

Рассмотрим пример: создадим объект-генератор gen с помощью так называемого генераторного выражения. Он будет считать квадраты чисел от 1 до 4 — такую последовательность создаёт функция range(1,5).

```
>>> a = (i**2 for i in range(1,5)) 
>>> a
<generator object <genexpr> at 0x0000023A7524D6D0> 
>>> next(a) 
1 
>>> next(a) 
 4 
>>> next(a) 
9 
>>> next(a) 
16 
>>> next(a) 
Traceback (most recent call last):   File "<stdin>", line 1, in <module> StopIteration`
```

Когда мы выведем на консоль переменную gen, то увидим лишь сообщение, что это объект-генератор.

При четырёх вызовах метода next(a) будут по одному рассчитываться и выводиться на консоль значения генератора: 1, 4, 9, 16. Причём в памяти будет сохраняться только последнее значение, а предыдущие сотрутся.

Когда мы попытаемся вызвать next(gen) в пятый раз, генератор сотрёт из памяти последний элемент (число 16) и выдаст исключение StopIteration.

```
`>>> next(gen) 
Traceback (most recent call last):   File "<stdin>", line 1, in <module> StopIteration`
```

Всё! Генератор больше не работает. Сколько бы мы ни вызывали next(gen), ничего считаться не будет. Чтобы запустить генератор ещё раз, придётся создавать его заново.

## И что, для вычисления генератора придётся много раз вызывать next()?

Нет, значения можно вычислять в цикле _for_. В этом случае метод next() вызывается неявно. Например:

```
>>> a = (i**2 for i in range(1,5)) 
>>> for i in a:     
		print(i) 
1 
4 
9 
16
```

Когда весь цикл пройден, произойдёт исключение StopIteration. Хотя на консоль сообщение об этом не выводится, но генератор помнит о нём и больше работать не будет. То есть цикл _for_ можно запускать только один раз, во второй раз не получится. Нельзя об этом забывать.

## И чем помогут генераторы в наших задачах?

Для этого сначала рассмотрим упрощённый способ создания генератора — с помощью генераторного выражения.

Генераторные выражения позволяют создавать объект-генератор в одну строчку. В общем случае их пишут по шаблону:

(_выражение for j in итерируемый объект if условие_)

Где _for,_ _in, if_ — ключевые слова, _j_ — переменная.

Пример генераторного выражения мы рассмотрели выше. Теперь посмотрим, как можно применить его для обработки большого файла.

**Перед нами задача**: на сервере есть огромный журнал событий log.txt, в котором хранятся сведения о работе какой-то системы за год. Из него нужно выбрать и обработать для статистики данные об ошибках — строки, содержащие слово error.

Такие строки можно выбрать и сохранить в памяти с помощью списка:

```
`with open(path + "\log.txt", "r") as log_file:
err_list = [st for st in log_file if "error" in st]`
```

Здесь path — путь к файлу log. В результате сформируется список вида:

[строка1, строка2, строка3, ….]

В списке e_l содержатся все строки со словом error, они записаны в память компьютера. Теперь их можно обработать в цикле. Недостаток метода в том, что, если таких строк будет слишком много, они переполнят память и вызовут ошибку _MemoryError_.

Переполнения памяти можно избежать, если организовать поточную обработку данных с использованием объекта-генератора. Мы создадим его с помощью генераторного выражения (оно отличается от генератора списка только круглыми скобками).

Рассмотрим следующий код:

```
with open("path\log.txt", "r") as log_file:
     err_gen = (st for st in log_file if "error" in st)
     for item in err_gen:
         <обработка строки item> 
```

- Генераторное выражение возвращает объект-генератор err_gen.
- Генератор начинает в цикле выбирать из файла по одной строке со словом error и передавать их на обработку.
- Обработанная строка стирается из памяти, а следующая записывается и обрабатывается. И так до конца цикла.

Этот метод не вызывает переполнения, так как в каждый момент времени в памяти находится только одна строка. При этом нужный для работы объём памяти не зависит от размера файла и количества строк, удовлетворяющих условию.

Генераторы часто используют при веб-скрапинге. Они позволяют поочерёдно получать нужные веб-страницы и обрабатывать их информацию. Это намного эффективнее, чем загрузить в память сразу все выбранные страницы и затем обрабатывать их в цикле.

## Как ещё можно создавать генераторы?

Генераторные выражения — это упрощённый вариант функций-генераторов, также создающих генераторы.

Функция-генератор отличается от обычной функции тем, что вместо команды return в ней используется yield. И если return завершает работу функции, то инструкция yield лишь приостанавливает её, при этом она возвращает какое-то значение.

При первом вызове метода next() выполняется код функции с первой команды до yield. При втором next() и последующих до конца генератора — код со следующей после yield команды и до тех пор, пока yield не встретится снова.

Чтобы было понятнее, рассмотрим небольшой пример:

```
>>> def f_gen(m):
...     s = 1
...     for n in range(1,m):
...         yield n**2 + s
...         s += 1
...
>>> a = f_gen(5)
>>> a
<generator object f_gen at 0x0000023EE468D6D0>
>>> for i in a:
...     print(i)
...
2
6
12
20
>>>
```

Здесь функция f_gen(5) при вызове создаёт генератор a. Мы видим это, когда выводим a на консоль.

Посчитаем значения генератора в цикле for.

- При первой итерации выполняется код функции до yield: переменная s =1, n = 1, yield возвращает 2.
- При второй итерации выполняется оператор после yield, далее к началу цикла и опять до yield: s = 2, n = 2, yield возвращает 6.
- Соответственно, при третьей и четвёртой итерации генерируются значения 12 и 20, после чего выполнение генератора прекращается.

Как видим, значения переменных _n и s_ между вызовами сохраняются.

Yield — инструмент очень гибкий. Его можно несколько раз использовать в коде функции-генератора. В этом случае команды yield служат разделителями кода: при первом вызове метода next() выполняется код до первого yield, при следующих вызовах — операторы между yield. При этом в генераторной функции необязательно должен быть цикл, все значения генератора и так посчитаются.

## Как создать бесконечную последовательность

Рассмотрим, как можно с помощью генератора создать математическую последовательность, например, программу, генерирующую простые числа (напоминаем, это числа, не имеющие делителей, кроме 1).

Наша программа будет последовательно анализировать целые числа больше 1. Для каждого числа n программа ищет делители в диапазоне от 2 до √n. Если делители есть, программа переходит к следующему числу. Если их нет, значит, n — число простое, и программа выводит его на печать.

```
>>> import math
>>> def prime_num():
...	 nm = 2
... 	while True:
...     	sq = math.ceil(nm**1/2)
...     	for i in range(2, sq+1):
...         	if (nm % i) == 0:
...            	break
...     	else:
...         	yield nm
...     	nm += 1
...
>>> for num in prime_num():
... 	print(num)
...
2
3
5
7
11
13
17
19
23
29
31
```

Этот код выдаёт бесконечную последовательность простых чисел без ограничения сверху. Остановить его можно только вручную.

Подобным образом с помощью генераторов можно создавать ряды случайных чисел, комбинаторные структуры, рекуррентные ряды, например, ряд Фибоначчи и другие последовательности.

## Какие ещё методы есть у генераторов?

Когда-то был один next (), но в [Python 2.5](https://www.python.org/dev/peps/pep-0342/) появилось ещё три метода:

- .close () — останавливает выполнение генератора;
- .throw () — генератор бросает исключение;
- .send () — интересный метод, позволяет отправлять значения генератору.

Рассмотрим пару небольших примеров.

Сначала на .close () и .throw ():

```
>>> def f_gen():
...     n = 1
...     while True:
...         yield n**2
...         n += 1
...
>>> generator1 = f_gen()
>>> generator2 = f_gen()
>>>
>>> for i in generator1:
...     print(i)
...     if i > 10:
...         generator1.close()
...
1
4
9
16
>>> for i in generator2:
...      print(i)
...      if i > 20:
...           generator2.throw(Exception("Плохо!"))
...
1
4
9
16
25
Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
  File "<stdin>", line 4, in f_gen
Exception: Плохо!
```

Программа создаёт два генератора, возвращающих бесконечную последовательность квадратов чисел. Их выполнение прекращается с помощью методов .close() и .throw().

Пример использования .send()

`>>> def generator(x): ...     while True: ...         x = yield x + 1 ... >>> g = generator(5) >>> g.send(None) 6 >>> g.send(10) 11 >>> g.send(15) 16 >>> g.send(4) 5`

Здесь мы не получаем значения генератора, а отправляем их на обработку с помощью метода .send().

С помощью этих методов можно создавать сопрограммы, или корутины, — это функции, которым можно передавать значения, приостанавливать и снова возобновлять их работу. Их обычно используют в Python для анализа потоков данных в корпоративной многозадачности. Генераторы позволяют создавать сложные разветвлённые программы для обработки потоков.

## Что ещё можно сказать

С изучения генераторов начинается освоение последовательной обработки гигантских потоков данных. Это может быть, например, трейдинг и технический анализ в биржевых операциях.

Но даже если не говорить о глобальных задачах, скрипты с применением генераторов — это способ избежать копирования данных в память. Генераторы позволяют экономить ресурсы компьютера и создавать красивый чистый код.

---
# tuple

## **Что такое кортежи**

**Кортежи** (**тип tuple**) — это неизменяемый тип данных в Python, который используется для хранения упорядоченной последовательности элементов.

У этих коллекций есть три замечательных свойства:

**Неизменяемость.** После того как кортеж создан, в него нельзя добавлять элементы, а также изменять их или удалять. При попытке это сделать интерпретатор выдаст ошибку TypeError.

**Упорядоченность.** Элементы кортежа располагаются в определённом порядке, который тоже неизменяем. К любому элементу можно обратиться по его индексу (порядковому номеру).

**Элементами кортежа могут быть объекты разных типов данных**: числа, строки, списки, другие кортежи и другие. Элементы-коллекции могут иметь неограниченную глубину вложенности. Например, кортеж может включать в себя список, который будет содержать другой список, который вновь будет содержать список и так далее.

Кортежи записываются с использованием круглых скобок ():

`   my_tuple = (значение1, значение2...)   `

my_tuple — имя переменной, которой присваивается кортеж.

(значение1, значение2...) — это сам кортеж, который содержит элементы значение1, значение2 и так далее.

Они могут состоять из элементов разных типов и их сочетаний:

```
# Кортеж из чисел, в том числе с плавающей точкой и комплексных 
numbers_tuple = (1, 2, 3, 4, 5, 2.5, 3 + 4j)  
# Кортеж из строк 
fruits_tuple = ('яблоко', 'банан', 'апельсин')  
# Кортеж из логических значений 
my_tuple = (True, False)  
# Кортеж из других кортежей 
nested_tuple = ((1, 2), ('a', 'b'))  
# Кортеж из списков 
my_tuple = ([1, 2, 3], ['a', 'b', 'c'])  
# Кортеж из словарей 
my_tuple = ({'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25})  
# Кортеж из разных типов данных 
mixed_tuple = (1, 'hello', [1, 2, 3], {'a': 10})  
```

## **Когда использовать кортеж**

Применение кортежей связано с их свойствами — неизменяемостью и строгим порядком элементов. Разберём ситуации, когда это полезно.

#### **Требуется защитить элементы от изменений**

Если нужно защитить данные от случайного или намеренного изменения, то можно использовать кортежи. Например, этот тип данных подойдёт для сохранения информации о датах рождения клиентов.

Обратите внимание: неизменяемость кортежей не абсолютна. У неё есть исключение — если внутри кортежа находятся изменяемые элементы, например списки, словари или множества, то их значения можно изменить.

Например:

```
# Кортеж с изменяемыми элементами: 
mutable_tuple = ([1, 2, 3], [4, 5, 6])   
print('Исходный кортеж:', mutable_tuple)  
# Изменение содержимого списка внутри кортежа 
mutable_tuple[0][1] = 10 
# Меняем второй элемент в первом списке 
mutable_tuple[1].append(7) 
# Добавляем ко второму списку новое значение  
print('Изменённый кортеж:', mutable_tuple)  
```

Результат выполнения кода:

```
Исходный кортеж: ([1, 10, 3], [4, 5, 6]) 
Изменённый кортеж: ([1, 10, 3], [4, 5, 6, 7])   
```

Как видите, никакой ошибки нет, хотя кортеж изменился.

#### **Необходимо экономить память**

Кортежи занимают в памяти меньше места, чем списки. Это легко проверить:

```
a = (10, 20, 30, 40, 50, 60) # Кортеж 
b = [10, 20, 30, 40, 50, 60] # Список  
print(a.__sizeof__()) # Размер кортежа 
print(b.__sizeof__()) # Размер списка
```

В результате выполнения кода получим:

```
72
88
```

Кортеж занимает в памяти на 16 байт меньше, чем список. Из-за малой величины сравниваемых объектов разница почти незаметна, но при работе с данными большего объёма экономия может быть значимой.

#### **Предстоит работать со словарями**

Кортежи идеально подходят для использования в качестве ключей в словарях, так как ключи в них должны быть объектами неизменяемого типа данных. Проверим это:

```
# Создаём словарь с кортежем в качестве ключа 
my_dict = {('a', 1): 'value1', ('b', 2): 'value2'}  
# Обращаемся к элементам словаря по кортежу в качестве ключа 
print(my_dict[('a', 1)])  
# Вывод: 
value1 print(my_dict[('b', 2)])  
# Вывод: 
value2  
# Добавляем новый элемент с кортежем в качестве ключа 
my_dict[('c', 3)] = 'value3'  
# Выводим содержимое словаря 
print(my_dict)   
```

В результате получим:

```
value1
value2 {('a', 1): 'value1', ('b', 2): 'value2', ('c', 3): 'value3'}
```

С кортежем словарь работает. Если попытаться в качестве ключа использовать список, то возникнет ошибка, так как списки — изменяемый тип данных.

## **Как работать с кортежами в Python**

Рассмотрим основные операции с кортежами.

### **Создание кортежа**

Создать кортеж в Python можно по меньшей мере пятью способами. Рассмотрим каждый из них.

- С помощью круглых скобок:

`   my_tuple = (1, 2, 3, 'a', 'b', 'c')   `

- Без круглых скобок:

`   my_tuple = 1, 2, 3, 'a', 'b', 'c'   `

- Используя встроенную функцию tuple():

`   my_tuple = tuple([1, 2, 3, 'a', 'b', 'c'])   `

- С помощью оператора упаковки, который мы разберём дальше:

`   a = 1 b = 2 c = 3 my_tuple = a, b, c  # Эквивалентно (a, b, c)   `

- Из итерируемого элемента, например строки, с помощью функции tuple():

`   my_tuple = tuple('hello') # Результат: ('h', 'e', 'l', 'l', 'o')   `

Можно создать пустой кортеж:

`   empty_tuple = ()   `

Если требуется кортеж, состоящий всего из одного элемента, то после элемента необходимо обязательно поставить запятую:

`   single_element_tuple = (42,) # Или так single_element_tuple = 42,  # Если запятую не поставить, то получим объект типа int single_element_tuple = (42)   `

### **Доступ к элементам по индексам**

Кортеж — это упорядоченная последовательность. Поэтому для доступа к его элементам можно использовать индексы.

Индексация начинается с нуля и заканчивается значением, равным длине кортежа, уменьшенным на единицу:

```
# Кортеж из шести элементов 
my_tuple = (1, 2, 3, 'a', 'b', 'c')  
# Доступ к элементам по индексу 
first_element = my_tuple[0] 
# Первый элемент 
second_element = my_tuple[1] 
# Второй элемент 
third_element = my_tuple[2] 
# Третий элемент 
last_element = my_tuple[5] 
# Последний элемент  # 
Вывод значений print(first_element)  
# Вывод: 1 
print(second_element) 
# Вывод: 2
print(third_element)  
# Вывод: 3
print(last_element)  
# Вывод: 'c'  
```

Для доступа к элементам с конца кортежа можно использовать отрицательные индексы. В этом случае индексация начинается с -1 и заканчивается значением, равным длине кортежа со знаком минус.

Напишем код:

```
my_tuple = (1, 2, 3, 'a', 'b', 'c')   
last_element = my_tuple[-1] # Первый элемент с конца 
second_to_last_element = my_tuple[-2] # Второй элемент с конца
first_element = my_tuple[-6] 
# Последний элемент с конца, он же первый с начала     
print(last_element)  # Вывод: 'c' 
print(second_to_last_element)  # Вывод: 'b'
print(first_element)  # Вывод: 1  
```

Чтобы обратиться ко вложенным элементам, используйте двойную индексацию:

```
nested_tuple = (1, 2, (3, 4), 5)  
# Обращение к элементам кортежа верхнего уровня 
print(nested_tuple[0])  # Вывод: 1 
print(nested_tuple[3])  # Вывод: 5  
# Обращение к элементам вложенного кортежа (3, 4) 
print(nested_tuple[2])  # Вывод: (3, 4) 
print(nested_tuple[2][0])  # Вывод: 3
print(nested_tuple[2][1])  # Вывод: 4 
```

Разберём код. Кортеж nested_tuple содержит вложенный кортеж (3, 4). Для доступа к элементам вложенного кортежа используем двойную индексацию: nested_tuple[2][0] обращается к первому элементу вложенного кортежа, а nested_tuple[2][1] обращается ко второму элементу.

### **Упаковка и распаковка**

Упаковка (packing) и распаковка (unpacking) — это операции, которые позволяют создавать кортеж из набора значений и извлекать значения из кортежа в переменные. Рассмотрим их подробнее.

**Упаковка кортежа.** Значения 1, 2, 3 и 'hello' автоматически упаковываются в кортеж:

```
my_tuple = 1, 2, 3, 'hello' 
# В переменной my_tuple теперь находится кортеж (1, 2, 3, 'hello') 
```

**Распаковка кортежа.** Элементы кортежа извлекаются в переменные:

```
a, b, c, d = my_tuple 
# Теперь переменные a, b, c, d содержат значения из кортежа 
# a = 1, b = 2, c = 3, d = 'hello'
```

**Обмен значениями между переменными.** С помощью упаковки и распаковки кортежей можно обменять значения переменных между собой без использования временной переменной.

Посмотрим пример кода:

```
x = 5 y = 10 # Обмен значениями с использованием кортежа, упаковки и распаковки x, y = y, x 
# Теперь переменные x и y содержат новые значения 
print('x =', x) # Вывод: x = 10
print('y =', y) # Вывод: y = 10  
```

Операция упаковки (y, x) сначала создаёт кортеж из двух значений (10, 5), затем операция распаковки (x, y) распаковывает кортеж и присваивает значения переменным x и y соответственно. Теперь переменная x содержит 10, а y содержит 5.

### **Сравнение**

Кортежи в Python сравниваются покомпонентно начиная с первого элемента до первого неравенства или до конца переменной. Если кортежи имеют одинаковую длину и все соответствующие элементы равны, то они считаются равными:

```
# Пример 1: кортежи с числовыми значениями 
tuple1 = (1, 2, 3) 
tuple2 = (1, 2, 3) 
print(tuple1 == tuple2)  # True, так как все элементы равны 

# Пример 2: кортежи с разными значениями 
tuple3 = (4, 5, 6) 
print(tuple1 == tuple3)  # False, так как первые элементы различаются  

# Пример 3: Сравнение кортежей разной длины 
tuple4 = (1, 2, 3, 4) 
print(tuple1 == tuple4)  # False, так как длина кортежей разная
```

Для сравнения используются стандартные операторы ==, !=, >, <, >=, <=.

При сравнении используются правила:

- когда сравниваются числовые элементы, большим считается тот кортеж, у которого первый отличающийся элемент больше;
- когда сравниваются строки, сравнение происходит по порядку в алфавите;
- элементы различных типов сравнивать нельзя — получим ошибку TypeError;
- если длины кортежей различны, то кортеж с меньшей длиной считается наименьшим.


### **Проверка принадлежности элемента**

Чтобы проверить, принадлежит ли элемент кортежу, используется оператор in. Если элемент присутствует в кортеже, оператор возвращает True, в противном случае — False.

```
my_tuple = (1, 2, 3, 4, 5)  
# Проверка, содержится ли число 3 в кортеже  
print(3 in my_tuple)  
# Вывод: True  
```

### **Перебор элементов**

Для перебора элементов кортежа в Python используется цикл for или while:

```
my_tuple = (1, 2, 3, 4, 5)  
# Перебор элементов кортежа с помощью цикла for 
for element in my_tuple:
	print(element)  # Вывод: 1 2 3 4 5  
	
# Перебор элементов кортежа с помощью цикла while 
i = 0 
while i < len(my_tuple):
	print(element[i])          
	i += 1  # Вывод: 1 2 3 4 5 
```

Код выводит каждый элемент кортежа my_tuple на новой строке.

### **Удаление кортежа**

Удалять из кортежа элементы нельзя, но можно удалить его полностью с помощью ключевого слова del:

```
my_tuple = (1, 2, 3, 4, 5)  # Удаление кортежа del my_tuple 
# Попробуем распечатать удалённый кортеж 
print(my_tuple)   # Ошибка: NameError: name 'my_tuple' is not defined  
```

В этом примере del my_tuple удаляет ссылку на кортеж из памяти. После этого переменной my_tuple больше не существует и попытка обратиться к ней вызовет ошибку NameError.

### **Конкатенация и повторение**

В Python для кортежей доступны операции конкатенации (сложения) и повторения (умножения). Эти операции могут использоваться при создании новых кортежей на основе существующих.

**Конкатенация.** Это объединение двух кортежей в один новый кортеж с помощью оператора +.

Напишем код:

```
tuple1 = (1, 2, 3) tuple2 = (4, 5, 6)   
concatenated_tuple = tuple1 + tuple2   
print('Конкатенация кортежей:', concatenated_tuple)
```

Результат:

```
Конкатенация кортежей: (1, 2, 3, 4, 5, 6)
```

**Повторение.** Этот способ создания кортежа напоминает арифметическое умножение: справа от исходного кортежа нужно добавить оператор * и указать, сколько раз он повторится.

```
original_tuple = (1, 2, 3)   
repeated_tuple = original_tuple * 3  
print('Повторение кортежа:', repeated_tuple)
```

Результат выполнения кода:

`   Повторение кортежа: (1, 2, 3, 1, 2, 3, 1, 2, 3)   `

При выполнении операций конкатенации и повторения создаются новые кортежи, а исходные остаются неизменными.

## **Функции кортежей Python**

В Python есть встроенные функции, которые облегчают работу с кортежами.

Во многих статьях можно встретить формулировку «методы кортежей», но это не совсем корректно. Метод — это понятие из объектно-ориентированного программирования, обозначающее функцию или процедуру, принадлежащую к какому-либо классу или объекту. Ниже мы говорим про функции, которые принимают и возвращают значения, без привязки к классам или объектам.

### **Определение длины, суммы, минимального и** **максимального элемента**

**Длину кортежа** можно получить функцией len(), которая возвращает количество элементов в кортеже:

```
my_tuple = (1, 2, 3, 4, 5)   
length_of_tuple = len(my_tuple)   
print('Длина кортежа:', length_of_tuple)
```

Результат:

`   Длина кортежа: 5   `

**Сумма элементов** рассчитывается легко запоминающейся функцией sum():

```
my_tuple = (1, 2, 3, 4, 5) 
sum_of_elements = sum(my_tuple) 
print('Сумма элементов кортежа:', sum_of_elements)  
```

Результат:

`   Сумма элементов кортежа: 15   `

Если кортеж пуст, len() и sum() возвращают 0.

**Минимальный и максимальный элементы** кортежа можно получить с помощью функций min() и max():

```
my_tuple = (1, 2, 3, 4, 5)   
min_element = min(my_tuple) 
max_element = max(my_tuple)   
print('Минимальный элемент кортежа:', min_element) 
print('Максимальный элемент кортежа:', max_element)  
```

Результат выполнения:

```
Минимальный элемент кортежа: 1 
Максимальный элемент кортежа: 5
```

Если кортеж пуст, то использование функций min() и max() вызовет ошибку ValueError.

### **Сортировка кортежа**

Элементы можно отсортировать по возрастанию или по убыванию. Так как кортежи относятся к неизменяемому типу данных, то кортеж с упорядоченными элементами нужно будет сохранить в новой переменной.

Для сортировки используется функция sorted():

```
# Исходный кортеж 
original_tuple = (3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)  
# Создаём новый кортеж с отсортированными элементами 
sorted_tuple = tuple(sorted(original_tuple))  
# Выводим результат 
print('Исходный кортеж:', original_tuple) 
print('Отсортированный кортеж:', sorted_tuple)  
```

Результат:

```
Исходный кортеж: (3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5) 
Отсортированный кортеж: (1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9)
```

Остановимся на коде:

- sorted(original_tuple) создаёт новый список, содержащий отсортированные элементы из original_tuple;
- tuple(...) создаёт новый кортеж из отсортированного списка.

Если нужна сортировка в обратном порядке, в функции sorted() используется параметр reverse=True:

```
original_tuple = (3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)   
sorted_tuple_reverse = tuple(sorted(original_tuple, reverse=True))   print('Отсортированный в обратном порядке кортеж:', sorted_tuple_reverse)
```

Получаем:

`   Отсортированный в обратном порядке кортеж: (9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1)   `

### **Срезы в кортежах**

Срезы используются для извлечения из кортежей подмножества элементов. Для этого необходимо указать начальный и конечный индекс, а также шаг среза.

Для определения начала и конца среза можно использовать положительные и отрицательные индексы:

- левый индекс указывает на элемент, с которого начинается срез;
- правый индекс указывает на элемент, которым заканчивается срез, этот элемент в срез не включается.

Получим срез, указав положительные индексы:

```
my_tuple = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)  
# Получение среза с элементами от 2 до 6 (не включая 6) 
subset_positive = my_tuple[2:6]   
print('Срез с положительными индексами:', subset_positive)
```

Результат:

`   Срез с положительными индексами: (2, 3, 4, 5)   `

Срез с отрицательными индексами:

```
my_tuple = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)  
# Срез с отрицательными индексами: начинаем с элемента с индексом -4 и заканчиваем элементом с индексом -1 (не включительно) 
negative_slice = my_tuple[-4:-1]   
print('Срез с отрицательными индексами:', negative_slice)
```

Результат:

`   Срез с отрицательными индексами: (6, 7, 8)   `

Если индексы пропущены, то срез будет включать все элементы от начала кортежа до заданного конца среза или от заданного начала среза до конца кортежа:

```
my_tuple = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)  
# Все элементы от начала кортежа до 7-го элемента (не включительно) slice_from_start = my_tuple[:7]  
# Все элементы от 3-го до конца кортежа 
slice_to_end = my_tuple[3:]   
print('Срез от начала до 7-го элемента:', slice_from_start) 
print('Срез от 3-го до конца:', slice_to_end)  
```

Результат:

```
Срез от начала до 7-го элемента: (0, 1, 2, 3, 4, 5, 6) 
Срез от 3-го до конца: (3, 4, 5, 6, 7, 8, 9)
```

### **Преобразование в другие типы данных**

В Python можно преобразовывать кортежи в другие типы данных: списки, строки, множества или словари.

Так можно превратить **кортеж в список**:

```
my_tuple = (1, 2, 3, 4, 5)  # Преобразование кортежа в список 
my_list = list(my_tuple)   
print('Кортеж:', my_tuple) print('Список:', my_list)
```

Результат:

```
Кортеж: (1, 2, 3, 4, 5) 
Список: [1, 2, 3, 4, 5] 
```

А так можно преобразовать **кортеж в строку**:

```
my_tuple = (1, 2, 3)  # Преобразование кортежа в строку 
my_string = ''.join(map(str, my_tuple))   
print('Кортеж:' my_tuple) 
print('Строка:', my_string)  
```

Здесь использовали встроенную функцию str.join. Работает она просто — переводит каждый элемент кортежа в строковый тип, а затем объединяет их в одну строку.

Результат:

```
Кортеж: (1, 2, 3) 
Строка: 123
```

Преобразовать **кортеж во множество**:

```
my_tuple = (1, 2, 3, 2, 4)  
# Преобразование кортежа во множество, при котором удаляются повторяющиеся элементы 
my_set = set(my_tuple)   
print('Кортеж:', my_tuple) 
print('Множество:', my_set)
```

Результат:

```
Кортеж: (1, 2, 3, 2, 4) 
Множество: {1, 2, 3, 4}
```

Множества — это неупорядоченные коллекции, которые состоят из уникальных элементов. Если преобразовать кортеж во множество, то все дубликаты в нём удалятся.

**Кортеж в словарь (пары «ключ — значение»):**

```
my_tuple = (('a', 1), ('b', 2), ('c', 3))  
# Преобразование кортежа в словарь 
my_dict = dict(my_tuple)   
print('Кортеж:', my_tuple) 
print('Словарь:', my_dict)  
```

Результат:

```
Кортеж: (('a', 1), ('b', 2), ('c', 3)) 
Словарь: {'a': 1, 'b': 2, 'c': 3} 
```

### **Как можно изменить элементы**

Хотя кортежи относятся к неизменяемым элементам, есть трюк, который позволяет их изменять. Для этого нужно перевести кортеж в список, сделать необходимые преобразования, а затем превратить полученный список в кортеж:

```
my_tuple = (1, 2, 3, 4, 5)  
# Преобразование кортежа в список 
my_list = list(my_tuple)  
# Изменение значения в списке 
my_list[2] = 10  
# Преобразование списка обратно в кортеж 
updated_tuple = tuple(my_list)   
print('Исходный кортеж:', my_tuple) 
print('Обновлённый кортеж:', updated_tuple)
```

Результат:

```
Исходный кортеж: (1, 2, 3, 4, 5) 
Обновлённый кортеж: (1, 2, 10, 4, 5)  
```

Другой подоход — создать новый кортеж с изменёнными значениями:

```
my_tuple = (1, 2, 3, 4, 5)  
# Создание нового кортежа с изменённым значением 
updated_tuple = my_tuple[:2] + (10,) + my_tuple[3:]   
print('Исходный кортеж:', my_tuple) 
print('Обновлённый кортеж:', updated_tuple) 
```

Результат:

```
Исходный кортеж: (1, 2, 3, 4, 5) 
Обновлённый кортеж: (1, 2, 10, 4, 5)
```

В этом примере создаём новый кортеж updated_tuple, включая все элементы кортежа my_tuple с начала до второго, добавляем к ним новое значение 10, а затем добавляем все элементы my_tuple начиная с четвёртого и до конца.

Мы рассмотрели только базовые понятия и операции с кортежами. Если вы хотите погрузиться в работу с ними глубже, то советуем [перейти к документации](https://python-reference.readthedocs.io/en/latest/docs/tuple/). И обязательно пишите код из примеров в своём редакторе кода или IDE — это поможет закрепить теорию.

---

## Двоичные типы данных

Двоичные типы данных в **Python** используются для хранения и манипулирования двоичными данными, такими как изображения или звуковые файлы.

В **Python** есть три типа данных, которые предназначены для хранения двоичных данных:

- **bytes** – неизменяемая последовательность байтов. Представляет двоичные данные, которые необходимо хранить в неизменяемом виде, например, содержимое изображения.
- **bytearray** – изменяемая последовательность байтов. Представляет двоичные данные, которые могут изменяться, например, кадры видео.
- **memoryview** – позволяет работать с памятью как с последовательностью байтов, что может быть полезным при работе с большими объемами данных.

**Пример:**

main.py

```python
# bytes
b = b'\x00\xff\x50'
print('Тип переменной, имеющей значение', b, 'это', type(b))

# bytearray
ba = bytearray(b)
print('Тип переменной, имеющей значение', ba, 'это', type(ba))

# memoryview
mv = memoryview(b)
print('Тип переменной, имеющей значение', mv, 'это', type(mv))
```

**Результат:**

Терминал

```sh
>>> Тип переменной, имеющей значение b'\x00\xffP' это <class 'bytes'>
>>> Тип переменной, имеющей значение bytearray(b'\x00\xffP') это <class 'bytearray'>
>>> Тип переменной, имеющей значение <memory at 0x7fcd3a8dd100> это <class 'memoryview'>
```

---

## Тип данных сопоставления (Словарь/Dict)

Тип данных Сопоставления в **Python** представлен словарем (**dict**), который используется для хранения ключей и связанных с ними значений. Ключи должны быть уникальными и неизменяемыми, а значения могут быть изменяемыми и не уникальными.

**Пример:**

main.py

```python
# Создание словаря
person = dict(name='John', age=30, city='New York')
person_alt = {'name': 'Alexandr', 'age': 25, 'city': 'Moscow'}

# Вывод словарей
print(person, person_alt)

# Тип данных
print(type(person))

print(type(person_alt))
```

**Результат:**

Терминал

```sh
>>> {'name': 'John', 'age': 30, 'city': 'New York'} {'name': 'Alexandr', 'age': 25, 'city': 'Moscow'}
>>> <class 'dict'>
>>> <class 'dict'>
```

---

## Логический тип данных

Логический тип данных **bool** в **Python** используется для представления истинности выражения, которое может иметь только два значения: **True** (истина) или **False** (ложь). Этот тип данных может быть полезен, например, для проверки условий и принятия решений на основе этих условий.

**Пример:**

main.py

```python
a = 10
b = 5
c = a > b
print('Результат сравнения', a, '>', b, 'это', c, 'тип', type(c))
```

**Результат:**

Терминал

```sh
>>> Результат сравнения 10 > 5 это True тип <class 'bool'>
```

---

## Тип данных множество

Тип данных множество (**set**) в **Python** представляет собой неупорядоченную коллекцию уникальных элементов. Основным применением множеств является проверка наличия элемента в коллекции, удаление дубликатов, нахождение пересечения, объединения и разности множеств.

Тип данных **frozenset**, в отличие от обычного множества **set**, является неизменяемым.

**Пример:**

main.py

```python
# создание множества
my_set = {1, 2, 3, 4, 5}

# вывод типа данных
print(type(my_set))  # <class 'set'>

# создание неизменяемого множества
my_frozenset = frozenset([1, 2, 3, 4, 5])

# вывод типа данных
print(type(my_frozenset))  # <class 'frozenset'>
```

**Результат:**

Терминал

```sh
>>> <class 'set'>
>>> <class 'frozenset'>
```
