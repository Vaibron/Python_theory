
# List (список) и Tuple (Кортеж)

> [!ВАЖНО ПОМНИТЬ]
> Кортежи имеют те же операции и сложности, что и списки, за исключением операций, которые изменяют список, поскольку кортежи неизменяемы.

Вычисления для среднего случая (Average Case) предполагает, что параметры сгенерированы случайно.

Внутри список представлен как массив; самые большие затраты возникают из-за превышения текущего размера выделения (поскольку все должно перемещаться) или из-за вставки или удаления где-то в начале (поскольку все, что после этого, должно перемещаться). Если вам нужно добавить/удалить на обоих концах, рассмотрите возможность использования вместо этого Collections.deque.

| **Operation**                                                            | **Average Case** | **[Amortized Worst Case](http://en.wikipedia.org/wiki/Amortized_analysis)** |
| ------------------------------------------------------------------------ | ---------------- | --------------------------------------------------------------------------- |
| Copy                                                                     | O(n)             | O(n)                                                                        |
| Append[1]                                                                | O(1)             | O(1)                                                                        |
| Pop last                                                                 | O(1)             | O(1)                                                                        |
| Pop intermediate[2]                                                      | O(n)             | O(n)                                                                        |
| Insert                                                                   | O(n)             | O(n)                                                                        |
| Get Item                                                                 | O(1)             | O(1)                                                                        |
| Set Item                                                                 | O(1)             | O(1)                                                                        |
| Delete Item                                                              | O(n)             | O(n)                                                                        |
| Iteration                                                                | O(n)             | O(n)                                                                        |
| Get Slice                                                                | O(k)             | O(k)                                                                        |
| Del Slice                                                                | O(n)             | O(n)                                                                        |
| Set Slice                                                                | O(k+n)           | O(k+n)                                                                      |
| Extend[1]                                                                | O(k)             | O(k)                                                                        |
| [Sort](http://svn.python.org/projects/python/trunk/Objects/listsort.txt) | O(n log n)       | O(n log n)                                                                  |
| Multiply                                                                 | O(nk)            | O(nk)                                                                       |
| x in s                                                                   | O(n)             |                                                                             |
| min(s), max(s)                                                           | O(n)             |                                                                             |
| Get Length                                                               | O(1)             | O(1)                                                                        |

---

# collections.deque (двусторонняя очередь)

Дек (двусторонняя очередь) внутренне представляется как двусвязный список. (Ну, для большей эффективности это список массивов, а не объектов.) Оба конца доступны, но даже просмотр середины происходит медленно, а добавление или удаление из середины происходит еще медленнее.

| **Operation** | **Average Case** | **Amortized Worst Case** |
| ------------- | ---------------- | ------------------------ |
| Copy          | O(n)             | O(n)                     |
| append        | O(1)             | O(1)                     |
| appendleft    | O(1)             | O(1)                     |
| pop           | O(1)             | O(1)                     |
| popleft       | O(1)             | O(1)                     |
| extend        | O(k)             | O(k)                     |
| extendleft    | O(k)             | O(k)                     |
| rotate        | O(k)             | O(k)                     |
| remove        | O(n)             | O(n)                     |
| Get Length    | O(1)             | O(1)                     |

---

# set (множество)

Смотрим dict -- сложность операций очень похожа

|   |   |   |   |
|---|---|---|---|
|**Operation**|**Average case**|**Worst Case**|**notes**|
|x in s|O(1)|O(n)||
|Union s\|t|[O(len(s)+len(t))](https://wiki.python.org/moin/TimeComplexity_%28SetCode%29)|||
|Intersection s&t|O(min(len(s), len(t)))|O(len(s) * len(t))|replace "min" with "max" if t is not a set|
|Multiple intersection s1&s2&..&sn||(n-1)*O(l) where l is max(len(s1),..,len(sn))||
|Difference s-t|O(len(s))|||
|s.difference_update(t)|O(len(t))|||
|Symmetric Difference s^t|O(len(s))|O(len(s) * len(t))||
|s.symmetric_difference_update(t)|O(len(t))|O(len(t) * len(s))||

- Как видно из [исходного кода](https://github.com/python/cpython/blob/master/Objects/setobject.c), сложности для установки разницы s-t или s.difference(t) (set_difference()) и разница установленных на месте s.difference_update(t) (set_difference_update_internal()) различны! Первый — O(len(s)) (для каждого элемента в s добавьте его в новый набор, если не в t). Второй — O(len(t)) (для каждого элемента t удалите его из s). Поэтому необходимо внимательно выбирать, какой из них предпочтительнее, в зависимости от того, какой из них самый длинный и нужен ли новый набор. 

- Для выполнения операций над множествами, таких как s-t, оба s и t должны быть множествами. Однако вы можете использовать эквиваленты метода, даже если t — любой итерируемый объект, например s.difference(l), где l — список.

---

# dict (словарь)

Среднее время выполнения операций, указанное для объектов dict, предполагает, что хэш-функция для объектов достаточно надежна, чтобы сделать коллизии редкими. Средний случай предполагает, что ключи, используемые в параметрах, выбираются равномерно случайным образом из набора всех ключей. 

Обратите внимание, что существует быстрый путь для диктов, которые (на практике) работают только с ключами str; это не влияет на алгоритмическую сложность, но может существенно влиять на постоянные факторы: скорость завершения типичной программы.

|   |   |   |
|---|---|---|
|**Operation**|**Average Case**|**Amortized Worst Case**|
|k in d|O(1)|O(n)|
|Copy[3]|O(n)|O(n)|
|Get Item|O(1)|O(n)|
|Set Item[1]|O(1)|O(n)|
|Delete Item|O(1)|O(n)|
|Iteration[3]|O(n)|O(n)|

> [!ПОМЕТКА]
> 
> [1] = Эти операции основаны на «амортизированной» части «амортизированного наихудшего случая». Отдельные действия могут занять удивительно много времени, в зависимости от истории контейнера.
> 
>  [2] = Удаление промежуточного элемента с индексом **k** из списка размера **n** сдвигает все элементы _after_ **k** на один слот влево с помощью memmove. **n - k** элементов необходимо переместить, поэтому операция равна **O(n - k)**. В лучшем случае — выталкивание предпоследнего элемента, что требует одного хода, в худшем случае — выталкивание первого элемента, что требует **n — 1** ходов. Средний случай среднего значения **k** — это перемещение элемента в середину списка, что требует операций **O(n/2) = O(n)**.
>  
> [3] = Для этих операций худший случай _n_ — это максимальный размер, которого когда-либо достигал контейнер, а не просто текущий размер. Например, если в словарь добавлено N объектов, а затем удалено N-1, размер словаря все равно будет рассчитан на N объектов (по крайней мере), пока не будет сделана еще одна вставка.