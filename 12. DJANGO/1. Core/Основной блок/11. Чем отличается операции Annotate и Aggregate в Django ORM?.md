
### Краткий ответ

**Aggregation** - обрабатывает все результаты запроса (queryset). (Возвращает только итоговый результат агрегации параметров объектов выборки((queryset)). Таким образом со стороны Python никаких промежуточных объектов создавать не приходится!)
**Annotation** - обрабатывает значение каждого объекта (item) в запросе (queryset) отдельно. (к каждому объекту (item) из выборки (queryset) применяется агрегирующая функция. Этот метод принимает те же агрегирующие функции, а возвращает метод QuerySet, объекты которого будут всё теми же экземплярами класса модели, но каждый объект будет иметь _дополнительные атрибуты_. Каждый атрибут будет хранить результат соответствующей агрегации _относительно текущего объекта_.)

### Подробно про Аннотирование и Агрегирование

Базы данных призваны не только хранить и накапливать данные. И даже если добавить к хранению выдачу данных по запросу, останется не упомянутой ещё одна обязанность, возлагаемая на СУБД: _анализ накопленных данных_.

Представим классический пример предметной области — "Книжный магазин". Главной сущностью в проекте, работающем в данной области, будет "книга":

```python

class Book(models.Model):
    # цену часто хранят в числовом поле фиксированной точности
    price = models.DecimalField(max_digits=10, decimal_places=2)
    # ...
    
```

Когда имеешь дело с некоторыми товарами, часто приходится вычислять _суммарную цену_ наборов товаров и _среднюю цену_ товаров набора. Python — язык достаточно выразительный, он позволяет ту же сумму посчитать прямо на месте:

```python

total_price = sum(book.price for book in Book.objects.all())

```

Средняя цена вычисляется ненамного сложнее. Однако будет ли такое решение оправданным?

ORM честно запросит все книги из базы и поместит данные каждой книги в объект класса `Book`. А затем в коде потребуется только цена — это уже выглядит как лишняя работа! И СУБД тоже потратит лишние ресурсы на загрузку всех столбцов таблицы, вместо того, чтобы достать ровно один. Когда дело касается крупного магазина книг, подобное использование БД неприемлемо.

Строго говоря, Django ORM умеет запрашивать только часть данных.

Ещё один минус подобной обработки на стороне Python заключается в том, что мы при этом не используем часть возможностей СУБД. Как уже было сказано, подсчёт сумм и средних значений — часто встречающиеся задачи. Поэтому большинство СУБД умеет выполнять такой анализ данных на своей стороне и сам язык SQL содержит средства для описания того, что же СУБД должна вычислить или, как ещё говорят, **выполнить _агрегацию_**. И разработчики СУБД вкладывают много сил в то, чтобы агрегация работала быстро. Осталось научиться описывать агрегацию с использованием Django ORM.

## Агрегация и агрегирующие функции

Для того чтобы получить уже агрегированные данные, нужно воспользоваться методом `.aggregate()`, вызвав его у имеющегося менеджера или QuerySet. Этот метод принимает в качестве параметров так называемые агрегирующие функции. Функций этих достаточно много, но все они используются примерно одинаково, поэтому рассмотрим для примера функцию `Avg`:

```python

from django.db.models import Avg

# Получение средней цены среди всех книг магазина
Book.objects.aggregate(Avg('price'))
# {'price__avg': 34.35}

# Можно задать имя ключа результирующего словаря явно
Book.objects.aggregate(average_price=Avg('price'))
# {'average_price': 34.35}
```

Если аргументы указываются как позиционные, то имена для ключей генерирует Django ORM на основе имени поля и имени агрегирующей функции. Аргументов можно указать сразу несколько и генерируемые имена не дадут запутаться:

```python

from django.db.models import Avg, Max, Min
Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))
# {'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')}

```

Как можно заметить, каждый запрос на агрегацию возвращает не сами книги, а только итоговый результат. Таким образом со стороны Python никаких промежуточных объектов создавать не приходится!

Другая задача для анализа найдутся. Предположим, что нужно для каждой записи в блоге некоторого автора узнать количество комментариев. Агрегация на первый взгляд не подходит: сами посты тоже нужны. Можно решить задачу "в лоб", написав:

```python

author = User.objects.get(id=1)
posts = [(p, p.postcomment_set.count()) for p in author.post_set.all()]

```

Такое решение имеет своё собственное название – "N+1 запросов" – поскольку будет выполнен один запрос N постов, а затем N запросов комментариев к каждому. Легко представить, насколько это неэффективно.

Для того чтобы для каждой возвращаемой сущности _вычислить_ некоторое значение в рамках одного запроса, Django ORM предоставляет **механизм _аннотирования_**.

## Аннотирование

Процесс, при котором к каждому объекту из выборки применяется агрегирующая функция, назвается аннотированием. Он описывается вызовом метода `.annotate()` применительно к менеджеру или QuerySet. Этот метод принимает те же агрегирующие функции, а возвращает метод QuerySet, объекты которого будут всё теми же экземплярами класса модели, но каждый объект будет иметь _дополнительные атрибуты_. Каждый атрибут будет хранить результат соответствующей агрегации _относительно текущего объекта_. Например, `.aggregate(Count('postcomment'))` подсчитает количество всех комментариев, а `.annotate(Count('postcomment'))` даст количество комментариев к каждому посту. Так выглядит подсчёт количества тегов, которыми помечен каждый пост:

```python

posts = Post.objects.annotate(Count('tags'))
posts[0].tags__count  # только тут финализируется запрос!
# SELECT "blog_post"."id",
#        ...
#        COUNT("blog_post_tags"."tag_id") AS "tags__count"
#   FROM "blog_post"
#   LEFT OUTER JOIN "blog_post_tags"
#     ON ("blog_post"."id" = "blog_post_tags"."post_id")
#  GROUP BY ...
#  LIMIT 1

# Execution time: 0.000563s [Database: default]

# => 2
```

Здесь новый атрибут получил имя "tags__count", но имя можно было указать вручную, как и в случае обычной агрегации.

## Аннотирование и дубликаты в выдаче

Если вы уже имеете некоторый опыт в SQL, вы можете задаться вопросом: а не добавляет ли `OUTER JOIN`, который можно заметить в примере выше, в выборку дублирующиеся элементы, если присовокупляемые сущности соотносятся с текущей как "многие к одному"? Добавляет! Более того, агрегация в таких случаях даёт неверные результаты, так как учитывает и повторяющиеся строки. И тем больше дублей вы увидите, чем больше разных связей "многие к одному" задействуете (и даже одну и ту же, но несколько раз).

Увы, в общем виде эту проблему не решить. Но конкретно агрегирующая функция `Count` имеет опцию `distinct=True`, которая убирает дублирование, пока вы используете только этот вид аннотаций и каждый `Count` используете с `distinct=True`.

## Агрегация аннотированных значений

Аннотирование позволяет добавить вычислимые данные к каждому элементу запроса, а это значит, что можно выполнить итоговую агрегацию с использованием этих значений! Получение среднего количества тегов среди всех постов будет выглядеть так:

```python

Post.objects.annotate(Count('tags')).aggregate(Avg('tags__count'))
# SELECT AVG("tags__count")
#   FROM (
#         SELECT COUNT("blog_post_tags"."tag_id") AS "tags__count"
#           FROM "blog_post"
#           LEFT OUTER JOIN "blog_post_tags"
#             ON ("blog_post"."id" = "blog_post_tags"."post_id")
#          GROUP BY "blog_post"."id"
#        ) subquery

# Execution time: 0.000361s [Database: default]

# => {'tags__count__avg': 1.5}
```