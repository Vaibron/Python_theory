
## Общий ответ на примере SQLAlchemy

Для подключения в SQLAlhemy.Core мы писали конструкцию:

```python

Conn = engine.connect() ## выполнение подключения к БД, чтобы получать данные или выполнять какие-либо манипуляции над данными.

```

Или SQLAlhemy.ORM

```python

Session = sessionmaker(bind=engine)
session = Session()

```

Дальше для выполнения запроса использовали:

```python

stmt = select(*названия столбцов или ‘*’ для вывода всей таблицы*).select_from(*название таблицы, с которой работаем*)

```

```python

conn.execute(stmt)

```

или

```python

stmt = update(*таблица*)where(*условие*).values(*присв. новое значение*)
b = session.execute(stmt)

```

  

.execute(stmt) - попытка выполнить запрос, если запрос успешно выполняется (SQLAlchemy нормально транслирует/переводит написанный запрос в SQL), то он отправляется нашей СУБД. **ПРОИСХОДИТ ОТПРАВКА ЗАПРОСА**

```python

b = session.commit()

```

Запрос отправлен, но не был подтвержден. Он существует в оперативной памяти, но изменения не были внесены до подтверждения. Собственно – commit это и делает. - **ПРОИСХОДИТ ВЫПОЛНЕНИЕ ЗАПРОСА.**

Теперь произведенные манипуляции будут отображаться у всех, кто работает со свежей версией БД.


# Ответ про особенности данного процесса в Django.

**Поведение транзакций Django по умолчанию**

По умолчанию Django работает в режиме **autocommit**. Каждый запрос немедленно фиксируется в базе данных, за исключением случаев, когда транзакция не активна.

**Почему Django использует autocommit**

В стандартах SQL каждый запрос SQL запускает транзакцию, за исключением случая, когда уже есть какая-то активная транзакция. Сначала транзакция отправляется в БД, а уже затем такие транзакции затем должны быть явно за'commit'чены или отменены.

Это не всегда удобно для разработчиков приложений. Чтобы облегчить эту проблему, большинство баз данных предоставляют режим автоматической фиксации (**autocommit**). Когда автофиксация включена и ни одна транзакция не активна, каждый SQL-запрос оборачивается отдельной транзакцией. Другими словами, каждый такой запрос не только запускает транзакцию, но и автоматически фиксируется или откатывается в зависимости от того, был ли запрос успешным. 

PEP 249, спецификация API базы данных Python версии 2.0, требует, чтобы **autocommit** изначально был отключен. 

Django переопределяет это значение по умолчанию и включает **autocommit**. Чтобы избежать этого, вы можете отключить управление транзакциями, но это не рекомендуется.