  
# 1. Инкапсуляция

Данные и методы можно скрывать в классах , т.е. работать можно только через разрешенные методы, а остальное скрыто внутри  

В Python'е инкапсуляция существует на уровне договоренности, т.е. даже если мы используем для атрибута два нижних подчеркивания, другой программист все же сможет обратиться к нашему атрибуту, если напишет нужный код.

> [!Как обратиться к атрибуту с уровнем закрытости private?]
> 

```python

class Geom:
    name = 'Geom'
 
    def __init__(self, x1, y1, x2, y2):
        print(f"инициализатор Geom для {self.__class__}")
        self.__x1 = x1
        self.__y1 = y1
        self.__x2 = x2
        self.__y2 = y2

print(f"{_Geom__x1}, {_Geom__y1}, {_Geom__x2}, {_Geom__y2}")

# Т.е. нужно написать _(Название класса)__(наименование атрибута)

```

Вся информация, которая нужна для работы конкретного объекта, должна храниться внутри этого объекта. Если нужно вносить изменения, методы для этого тоже должны лежать в самом объекте — посторонние объекты и классы этого делать не могут. Для внешних объектов доступны только публичные атрибуты и методы. 

Например, метод для внесения данных в карточку товара должен обязательно быть прописан в классе «Карточка товара». А не в классе «Корзина» или «Каталог товаров». 

Такой принцип обеспечивает безопасность и не даёт повредить данные внутри какого-то класса со стороны. Ещё он помогает избежать случайных зависимостей, когда из-за изменения одного объекта что-то ломается в другом.

---  
# 2. Наследование 

Позволяет вынести общее для классов.  
Можно вынести в общий базовый класс, чтобы не повторять код (дочерние классы)  
Мы можем использовать ранее использованные классы, и расширять их  

В этом принципе — вся суть объектно-ориентированного программирования.   
Разработчик создаёт: 

● Класс с определёнными свойствами;  
● Подкласс на его основе, который берёт свойства класса и добавляет свои;  
● Объект подкласса, который также копирует его свойства и добавляет свои. 

Каждый дочерний элемент наследует методы и атрибуты, прописанные в родительском. Он может использовать их все, отбросить часть или добавить новые. При этом заново прописывать эти атрибуты и методы не нужно. 

Например, в каталоге товаров:

1. У класса «Карточка товара» есть атрибуты тип товара, название, цена, производитель, а также методы «Вывести карточку» и «Обновить цену».
2. Подкласс «Смартфон» берёт все атрибуты и методы, записывает в атрибут «тип товара» слово «смартфон плюс добавляет свои атрибуты — «Количество сим-карт» и «Ёмкость аккумулятора».
3. Объект «Смартфон Xiaomi 11» заполняет все атрибуты своими значениями и может использовать методы класса «Карточка товара».

Наследование хорошо видно в примере кода выше, когда сначала создавали класс, потом подкласс, а затем объект с общими свойствами.

---  
# 3. Полиморфизм 

В буквальном значении полиморфизм означает множество форм.

Полиморфизм — очень важная идея в программировании. Она заключается в использовании единственной сущности(метод, оператор или объект) для представления различных типов в различных сценариях использования.

Принцип позволяет через единый интерфейс работать с объектами разных классов  

Существует два типа полиморфизма -  

- Ad hoc - до ОПП через перегрузку ф-ий и приведение данных  
- Параметрический - мы можем оперировать разными типами объектов через их базовый класс, т.е. можно от общего класса создать новый дочерний переопределенный класс, что позволяет нам делать более гибкую и абстрактную программу

## Пример 1: полиморфизм оператора сложения

Мы знаем, что оператор `+` часто используется в программах на Python. Но он не имеет единственного использования.

Для целочисленного типа данных оператор `+` используется чтобы сложить операнды.

```python

num1 = 1
num2 = 2
print(num1 + num2)

```

Итак, программа выведет на экран `3`.

Подобным образом оператор `+` для строк используется для конкатенации.

```python

str1 = "Python"
str2 = "Programming"
print(str1+" "+str2)

```

В результате будет выведено `Python Programming`.

Здесь мы можем увидеть единственный оператор `+` выполняющий разные операции для различных типов данных. Это один из самых простых примеров полиморфизма в Python.

## Полиморфизм в классах

Полиморфизм — очень важная идея в объектно-ориентированном программировании.

Мы можем использовать идею полиморфизма для методов класса, так как разные классы в Python могут иметь методы с одинаковым именем.

Позже мы сможем обобщить вызов этих методов, игнорируя объект, с которым мы работаем. Давайте взглянем на пример:

## Пример 3: полиморфизм в методах класса

```python

class Cat:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def info(self):
        print(f"I am a cat. My name is {self.name}. I am {self.age} years old.")

    def make_sound(self):
        print("Meow")


class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def info(self):
        print(f"I am a dog. My name is {self.name}. I am {self.age} years old.")

    def make_sound(self):
        print("Bark")


cat1 = Cat("Kitty", 2.5)
dog1 = Dog("Fluffy", 4)

for animal in (cat1, dog1):
    animal.make_sound()
    animal.info()
    animal.make_sound()

```

**Вывод:**

```

Meow
I am a cat. My name is Kitty. I am 2.5 years old.
Meow
Bark
I am a dog. My name is Fluffy. I am 4 years old.
Bark

```

Здесь мы создали два класса `Cat` и `Dog`. У них похожая структура и они имеют методы с одними и теми же именами `info()` и `make_sound()`.

Однако, заметьте, что мы не создавали общего класса-родителя и не соединяли классы вместе каким-либо другим способом. Даже если мы можем упаковать два разных объекта в кортеж и итерировать по нему, мы будем использовать общую переменную `animal`. Это возможно благодаря полиморфизму.

---
# 4. Абстракция

Абстра́кция в объектно-ориентированном программировании — это **использование только определения характеристик объекта, без описания их конкретных/детальных реализаций**. Основная идея состоит в том, чтобы представить объект обладающим набором методов и при этом не предоставлять конкретную логику этих методов.

Абстракция — один из принципов ООП в программировании. По своей сути это процесс выделения общих характеристик и функциональности объектов или системы, игнорируя детали реализации.

### Для чего нужна абстракция в программировании?

Абстракция позволяет разрабатывать программы на различных языках программирования, скрывая сложность и детали нижележащего кода. Это делается для упрощения сложных систем и концепций, чтобы разработчики могли фокусироваться на основных аспектах проблемы и легче понимали код.

### Преимущества абстракции в ООП

В объектно-ориентированном программировании абстракция играет важную роль. Она позволяет создавать абстрактные классы и интерфейсы, которые определяют общие свойства и методы, не зависящие от конкретной реализации. Преимущества абстракции ООП включают:

1. Упрощение сложности: абстракция в программировании позволяет скрыть детали реализации и сосредоточиться на ключевых аспектах системы. Это помогает упростить понимание и поддержку кода.
2. Модульность: возможность разбить систему на модули или классы, которые могут работать независимо друг от друга. Это способствует повторному использованию кода и улучшает масштабируемость проекта.
3. Повышение безопасности: абстракция позволяет скрыть некоторые детали реализации, что делает код более безопасным и защищенным. Внешние компоненты не имеют прямого доступа к внутренним деталям объекта или системы.


