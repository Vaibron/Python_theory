
## Модификаторы доступа в Python

Python не предоставляет никакой системы строгой инкапсуляции, которая присуща некоторым языкам программирования. Из-за этого вы можете получить доступ к любому атрибуту или методу класса из внешнего кода. Однако существует общепринятое соглашение между разработчиками, что атрибуты и методы, предназначенные для внутреннего использования, должны начинаться с подчеркивания (например, `_visible`). Это подчеркивание служит индикатором для других разработчиков, что этот атрибут или метод не должен изменяться напрямую извне. Но всегда следует помнить, что Python не предоставляет никаких средств для принудительного соблюдения этого соглашения, и атрибуты с подчеркиванием по-прежнему доступны извне.

## Публичные атрибуты и методы

Свойства видимости объектов оказывают влияние не только на внешнее поведение объектов, но и на взаимодействие между классами, которые наследуют их. Публичные свойства и методы доступны всем наследникам и создаются простым определением их в теле класса без каких-либо особых префиксов. К ним можно обращаться как внутри объекта, так и снаружи.

В следующем примере мы создаем два класса: `HTMLElement` и `DivElement`. `DivElement` является потомком `HTMLElement` и наследует его атрибуты и методы:

```python

class HTMLElement:
    def __init__(self):
        self.visible = True

    def is_visible(self):
        return self.visible

class DivElement(HTMLElement):
    def is_visible_property_from_parent(self):
        return self.visible

    def is_visible_method_from_parent(self):
        return self.is_visible()

div = DivElement()

# Вызов родительского свойства напрямую
print(div.visible) # => True
# Вызов родительского метода напрямую
print(div.is_visible()) # => True

# Вызов родительского свойства изнутри объекта
print(div.is_visible_property_from_parent()) # => True

# Вызов родительского метода изнутри объекта
print(div.is_visible_method_from_parent()) # => True

```

Здесь `DivElement` имеет доступ как к атрибуту `visible`, так и к методу `is_visible()`, унаследованным от `HTMLElement`.

Количество классов в цепочке наследования не влияет на это поведение. Любой подкласс `DivElement` тоже получит доступ к публичным частям `HTMLElement`:

```python

class DivElementWithEmptyBody(DivElement):
    pass

div = DivElementWithEmptyBody()

# Вызов родительского свойства напрямую
print(div.visible) # => True
# Вызов родительского метода напрямую
print(div.is_visible()) # => True

# Вызов родительского свойства изнутри объекта
print(div.is_visible_property_from_parent()) # => True
# Вызов родительского метода изнутри объекта
print(div.is_visible_method_from_parent()) # => True

```

В данном примере мы видим, что `DivElementWithEmptyBody` наследуется от `DivElement` и имеет доступ к атрибутам и методам классов `DivElement` и `HTMLElement`.

Наследование не влияет на поведение свойств внутри объектов. Значение `visible` в каждом конкретном объекте связано только с этим объектом:

```python

div1 = DivElementWithEmptyBody()
div2 = DivElement()

print(div1.visible) ## => True
print(div2.visible) ## => True

div1.visible = False
print(div1.visible) ## => False
print(div2.visible) ## => True

```

Хотя публичные атрибуты и методы имеют свои преимущества, например, доступность из любого места кода, они также могут представлять определенные риски. К ним можно обращаться и изменять их напрямую из любого класса, что может привести к неожиданным последствиям. Поэтому в некоторых случаях предпочтительно использовать приватные атрибуты и методы.

## Приватные атрибуты и методы

Свойства и методы с приватным модификатором доступа доступны только внутри того класса, где они были определены. Приватные свойства и методы в Python создаются путем добавления двойного подчеркивания (`__`) перед именем атрибута или метода.

Наследники не могут получить доступ к приватным свойствам и методам. Подразумевается, что приватные сущности — это нечто персональное для класса — его внутренняя реализация, которую нельзя выставлять наружу. Но это не отменяет возможности взаимодействовать с приватными данными через публичный интерфейс:

```python

class HTMLElement:
    def __init__(self):
        self.__visible = True

    def is_visible(self):
        return self.__visible

class DivElement(HTMLElement):
    pass

div = DivElement()

print(div.is_visible()) # => True
print(div.__visible)
# ...
# AttributeError: 'DivElement' object has no attribute '__visible'
```

Здесь прямой доступ к приватному атрибуту `__visible` вызывает ошибку. При этом мы все еще можем получить доступ к значению этого атрибута через публичный метод `is_visible()`.

Приватный модификатор доступа представляет собой мощный механизм инкапсуляции, который позволяет скрыть детали реализации класса. Это помогает сохранить целостность данных и избежать нежелательных изменений во внутреннем состоянии объекта.

Но что делать, когда нам нужен компромисс между полной открытостью публичных и строгим ограничением приватных атрибутов и методов? Для данной ситуации существуют защищенные атрибуты и методы.

## Защищенные атрибуты и методы

Защищенные атрибуты и методы имеют необычное поведение. Это смесь между публичными и приватными.

Они создаются путем добавления одного подчеркивания (`_`) перед именем атрибута или метода. Также они используются, когда разработчик хочет запретить доступ снаружи объекта, но дать возможность работать с ними внутри объекта класса-наследника или суперкласса.

Посмотрим, как это работает на практике:

```python

class HTMLElement:
    def __init__(self):
        self._visible = True

    def is_visible(self):
        return self._visible

class DivElement(HTMLElement):
    def isVisiblePropertyFromParent(self):
        return self._visible

div = DivElement()

# Доступно внутри через родительский метод
print(div.is_visible()) # => True

# Доступно внутри напрямую
print(div.isVisiblePropertyFromParent()) # => True

# Доступно снаружи, но это нарушает соглашение
print(div._visible)    # => True

```

Защищенные атрибуты и методы в Python рассматриваются как внутренние части класса, и, хотя они могут быть доступны извне, это считается плохой практикой. Вместо этого следует придерживаться соглашения и не обращаться к ним напрямую.