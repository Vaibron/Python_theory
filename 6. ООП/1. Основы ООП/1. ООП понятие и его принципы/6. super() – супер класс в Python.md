
super() – это встроенная функция языка Python. Она возвращает прокси-объект, который делегирует вызовы методов классу-родителю (или собрату) текущего класса (или класса на выбор, если он указан, как параметр).

Основное ее применение и польза – получения доступа из класса наследника к методам класса-родителя в том случае, если наследник переопределил эти методы.

> Что такое прокси-объект? Прокси, по-русски, это заместитель. То есть это объект, который по смыслу должен вести себя почти так же, как замещенный объект. Как правило он перенаправляет вызовы своих методов к другому объекту.

Давайте рассмотрим пример наследования. Есть какой-то товар в классе **Base** с базовой ценой в 10 единиц. Нам понадобилось сделать распродажу и скинуть цену на 20%. Хардкодить – это непрофессионально и негибко:

```python

class Base:
    def price(self):
        return 10


class Discount(Base):
    def price(self):
        return 8

```

Гораздо лучше было бы получить цену из родительского класса **Base** и умножить ее на коэффициент 0.8, что даст 20% скидку. Однако, если мы вызовем `self.price()` в методе `price()` мы создадим бесконечную рекурсию, так как это и есть один и тот же метод класса **Discount**! Тут же нужен метод `Base.price()`. Тогда его и вызовем по имени класса:

```python

class Discount(Base):
	def price(self):
		return Base.price(self) * 0.8
		
```

десь, надо не забыть указать **self** при вызове первым параметром явно, чтобы метод был привязан к текущему объекту. Это будет работать, но этот код не лишен изъянов, потому что необходимо явно указывать имя предка. Представьте, если иерархия классов начнет разрастаться? Например, нам нужно будет вставить между этими классами еще один класс, тогда придется редактировать имя класса-родителя в методах **Discount**:

```python

class Base:
    def price(self):
        return 10


class InterFoo(Base):
    def price(self):
        return Base.price(self) * 1.1


class Discount(InterFoo):  # <-- 
    def price(self):
        return InterFoo.price(self) * 0.8  # <-- 

```

ут на помощь приходит `super()`! [Супер](https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%BF%D0%B5%D1%80%D0%BA%D0%BB%D0%B0%D1%81%D1%81_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) он не потому что, подобно Супермэну, помогает всем людям, а потому что обращается к атрибутам классов стоящих над ним в порядке наследования (кто учил матан, вспомнят понятие _супремум_).

Будучи вызванным без параметров внутри какого-либо класса, **super()** вернет прокси-объект, методы которого будут искаться только в классах, стоящих ранее, чем он, в порядке [MRO](https://tirinox.ru/mro-python/). То есть, это будет как будто бы тот же самый объект, но он будет игнорировать все определения из текущего класса, обращаясь только к родительским:

```python

class Base:
    def price(self):
        return 10


class InterFoo(Base):
    def price(self):
        return super().price() * 1.1


class Discount(InterFoo):
    def price(self):
        return super().price() * 0.8

```
