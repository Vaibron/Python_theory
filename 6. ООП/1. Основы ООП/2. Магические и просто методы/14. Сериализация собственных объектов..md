
Модуль pickle не только для встроенных типов. Он может использоваться с каждым классом, реализующим его протокол. Этот протокол содержит четыре необязательных метода, позволяющих настроить то, как pickle будет с ними обращаться (есть некоторые различия для расширений на C, но это за рамками нашего руководства):  
  

- `__getinitargs__(self)`  
    Если вы хотите, чтобы после десериализации вашего класса был вызыван `__init__`, вы можете определить `__getinitargs__`, который должен вернуть кортеж аргументов, который будет отправлен в `__init__`. Заметьте, что этот метод работает только с классами старого стиля.  



- `__getnewargs__(self)`  
    Для классов нового стиля вы можете определить, какие параметры будут переданы в `__new__` во время десериализации. Этот метод так же должен вернуть кортеж аргументов, которые будут отправлены в `__new__`.  


- `__getstate__(self)`  
    Вместо стандартного атрибута `__dict__`, где хранятся атрибуты класса, вы можете вернуть произвольные данные для сериализации. Эти данные будут переданы в `__setstate__` во время десериализации.  


- `__setstate__(self, state)`  
    Если во время десериализации определён `__setstate__`, то данные объекта будут переданы сюда, вместо того чтобы просто записать всё в `__dict__`. Это парный метод для `__getstate__`: когда оба определены, вы можете представлять состояние вашего объекта так, как вы только захотите.  


- `__reduce__(self)`  
    Если вы определили свой тип (с помощью Python's C API), вы должны сообщить Питону как его сериализовать, если вы хотите, чтобы он его сериализовал. `__reduce__()` вызывается когда сериализуется объект, в котором этот метод был определён. Он должен вернуть или строку, содержащую имя глобальной переменной, содержимое которой сериализуется как обычно, или кортеж. Кортеж может содержать от 2 до 5 элементов: вызываемый объект, который будет вызван, чтобы создать десериализованный объект, кортеж аргументов для этого вызываемого объекта, данные, которые будут переданы в `__setstate__` (опционально), итератор списка элементов для сериализации (опционально) и итератор словаря элементов для сериализации (опционально).  


- `__reduce_ex__(self, protocol)`  
    Иногда полезно знать версию протокола, реализуя `__reduce__`. И этого можно добиться, реализовав вместо него `__reduce_ex__`. Если `__reduce_ex__` реализован, то предпочтение при вызове отдаётся ему (вы всё-равно должны реализовать `__reduce__` для обратной совместимости).  

### Пример

Для примера опишем грифельную доску (`Slate`), которая запоминает что и когда было на ней записано. Впрочем, конкретно эта доска становится чистой каждый раз, когда она сериализуется: текущее значение не сохраняется.

```python

import time

class Slate:
    '''Класс, хранящий строку и лог изменений. И забывающий своё значение после 
    сериализации.'''

    def __init__(self, value):
        self.value = value
        self.last_change = time.asctime()
        self.history = {}

    def change(self, new_value):
        # Изменить значение. Зафиксировать последнее значение в истории. 
        self.history[self.last_change] = self.value
        self.value = new_value
        self.last_change = time.asctime()

    def print_changes(self):
        print 'Changelog for Slate object:'
        for k, v in self.history.items():
            print '%s\t %s' % (k, v)

    def __getstate__(self):
        # Намеренно не возвращаем self.value or self.last_change.
        # Мы хотим "чистую доску" после десериализации.
        return self.history

    def __setstate__(self, state):
        self.history = state
        self.value, self.last_change = None, None

```