
В Питоне уйма магических методов, созданных для определения интуитивного сравнения между объектами используя операторы, а не неуклюжие методы. Кроме того, они предоставляют способ переопределить поведение Питона по-умолчанию для сравнения объектов (по ссылке). Вот список этих методов и что они делают:  
  

- `__cmp__(self, other)`  
    Самый базовый из методов сравнения. Он, в действительности, определяет поведение для всех операторов сравнения (>, `==`, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). `__cmp__` должен вернуть отрицательное число, если `self < other`, ноль, если `self == other`, и положительное число в случае `self > other`. Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в `__cmp__`. Но `__cmp__` может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперерируют одним критерием.  
      
    
- `__eq__(self, other)`  
    Определяет поведение оператора равенства, `==`.  
      
    
- `__ne__(self, other)`  
    Определяет поведение оператора неравенства, `!=`.  
      
    
- `__lt__(self, other)`  
    Определяет поведение оператора меньше, `<`.  
      
    
- `__gt__(self, other)`  
    Определяет поведение оператора больше, `>`.  
      
    
- `__le__(self, other)`  
    Определяет поведение оператора меньше или равно, `<=`.  
      
    
- `__ge__(self, other)`  
    Определяет поведение оператора больше или равно, `>=`.  
      
    

  
Для примера расcмотрим класс, описывающий слово. Мы можем сравнивать слова лексиграфически (по алфавиту), что является дефолтным поведением при сравнении строк, но можем захотеть использовать при сравнении какой-нибудь другой критерий, такой, как длина или количество слогов. В этом примере мы будем сравнивать по длине. Вот реализация:

```python

class Word(str):
    '''Класс для слов, определяющий сравнение по длине слов.'''

    def __new__(cls, word):
        # Мы должны использовать __new__, так как тип str неизменяемый
        # и мы должны инициализировать его раньше (при создании)
        if ' ' in word:
            print "Value contains spaces. Truncating to first space."
            word = word[:word.index(' ')] # Теперь Word это все символы до первого пробела
        return str.__new__(cls, word)

    def __gt__(self, other):
        return len(self) > len(other)
    def __lt__(self, other):
        return len(self) < len(other)
    def __ge__(self, other):
        return len(self) >= len(other)
    def __le__(self, other):
        return len(self) <= len(other)

```