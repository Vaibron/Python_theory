
## Создание произвольных последовательностей

  
В Питоне существует множество способов заставить ваши классы вести себя как встроенные последовательности (словари, кортежи, списки, строки и так далее). Это, безусловно, мои любимые магические методы, из-за до абсурда высокой степени контроля, которую они дают и той магии, от которой с экземплярами ваших классов вдруг начинает прекрасно работать целое множество глобальных функций. Но, до того как мы перейдём ко всяким хорошим вещам, мы должны знать о протоколах.  
#### Протоколы

Теперь, когда речь зашла о создании собственных последовательностей в Питоне, пришло время поговорить о _протоколах_. Протоколы немного похожи на интерфейсы в других языках тем, что они предоставляют набор методов, которые вы должны реализовать. Однако, в Питоне протоколы абсолютно ни к чему не обязывают и не требуют обязательно реализовать какое-либо объявление. Наверное, они больше похожи на руководящие указания.  
  
Почему мы заговорили о протоколах? Потому, что реализация произвольных контейнерных типов в Питоне влечёт за собой использование некоторых из них. Во-первых, протокол для определения неизменяемых контейнеров: чтобы создать неизменяемый контейнер, вы должны только определить `__len__` и `__getitem__` (продробнее о них дальше). Протокол изменяемого контейнера требует того же, что и неизменяемого контейнера, плюс `__setitem__` и `__delitem__`. И, наконец, если вы хотите, чтобы ваши объекты можно было перебирать итерацией, вы должны определить `__iter__`, который возвращает итератор. Этот итератор должен соответствовать протоколу итератора, который требует методов `__iter__`(возвращает самого себя) и `next`.  
  
#### Магия контейнеров

Без дальнейшего промедления, вот магические методы, используемые контейнерами:  
  

- `__len__(self)`  
    Возвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.  


- `__getitem__(self, key)`  
    Определяет поведение при доступе к элементу, используя синтаксис `self[key]`. Тоже относится и к протоколу изменяемых и к протоколу неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: `TypeError` если неправильный тип ключа и `KeyError` если ключу не соответствует никакого значения.  


- `__setitem__(self, key, value)`  
    Определяет поведение при присваивании значения элементу, используя синтаксис `self[nkey] = value`. Часть протокола изменяемого контейнера. Опять же, вы должны выбрасывать `KeyError` и `TypeError` в соответсвующих случаях.  


- `__delitem__(self, key)`  
    Определяет поведение при удалении элемента (то есть `del self[key]`). Это часть только протокола для изменяемого контейнера. Вы должны выбрасывать соответствующее исключение, если ключ некорректен.  


- `__iter__(self)`  
    Должен вернуть итератор для контейнера. Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции `iter()` и в случае перебора элементов контейнера выражением `for x in container:`. Итераторы сами по себе объекты и они тоже должны определять метод `__iter__`, который возвращает `self`.  


- `__reversed__(self)`  
    Вызывается чтобы определить поведения для встроенной функции `reversed()`. Должен вернуть обратную версию последовательности. Реализуйте метод только если класс упорядоченный, как список или кортеж.  


- `__contains__(self, item)`  
    `__contains__` предназначен для проверки принадлежности элемента с помощью `in` и `not in`. Вы спросите, почему же это не часть протокола последовательности? Потому что когда `__contains__` не определён, Питон просто перебирает всю последовательность элемент за элементом и возвращает `True` если находит нужный.  


- `__missing__(self, key)`  
    `__missing__` используется при наследовании от `dict`. Определяет поведение для для каждого случая, когда пытаются получить элемент по несуществующему ключу (так, например, если у меня есть словарь `d` и я пишу `d["george"]` когда `"george"` не является ключом в словаре, вызывается `d.__missing__("george")`).  


#### Пример

Для примера, давайте посмотрим на список, который реализует некоторые функциональные конструкции, которые вы могли встретить в других языках (Хаскеле, например).

```python

class FunctionalList:
    '''Класс-обёртка над списком с добавлением некоторой функциональной магии: head,
    tail, init, last, drop, take.'''

    def __init__(self, values=None):
        if values is None:
            self.values = []
        else:
            self.values = values

    def __len__(self):
        return len(self.values)

    def __getitem__(self, key):
        # если значение или тип ключа некорректны, list выбросит исключение
        return self.values[key]

    def __setitem__(self, key, value):
        self.values[key] = value

    def __delitem__(self, key):
        del self.values[key]

    def __iter__(self):
        return iter(self.values)

    def __reversed__(self):
        return FunctionalList(reversed(self.values))

    def append(self, value):
        self.values.append(value)
    def head(self):
        # получить первый элемент
        return self.values[0]
    def tail(self):
        # получить все элементы после первого
        return self.values[1:]
    def init(self):
        # получить все элементы кроме последнего
        return self.values[:-1]
    def last(self):
        # получить последний элемент
        return self.values[-1]
    def drop(self, n):
        # все элементы кроме первых n
        return self.values[n:]
    def take(self, n):
        # первые n элементов
        return self.values[:n]

```

