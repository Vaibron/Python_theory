
В Питоне 2.5 было представлено новое ключевое слово вместе с новым способом повторно использовать код, ключевое слово `with`. Концепция менеджеров контекста не являлась новой для Питона (она была реализована раньше как часть библиотеки), но в [PEP 343](http://www.python.org/dev/peps/pep-0343/) достигла статуса языковой конструкции. Вы могли уже видеть выражения с `with`:  
  

```python

with open('foo.txt') as bar:    
	# выполнение каких-нибудь действий с bar
	
```

  
Менеджеры контекста позволяют выполнить какие-то действия для настройки или очистки, когда создание объекта обёрнуто в оператор `with`. Поведение менеджера контекста определяется двумя магическими методами:  
  

- `__enter__(self)`  
    Определяет, что должен сделать менеджер контекста в начале блока, созданного оператором `with`. Заметьте, что возвращаемое `__enter__` значение и есть то значение, с которым производится работа внутри `with`.  


- `__exit__(self, exception_type, exception_value, traceback)`  
    Определяет действия менеджера контекста после того, как блок будет выполнен (или прерван во время работы). Может использоваться для контроллирования исключений, чистки, любых действий которые должны быть выполнены незамедлительно после блока внутри with. Если блок выполнен успешно, `exception_type`, `exception_value`, и `traceback` будут установлены в `None`. В другом случае вы сами выбираете, перехватывать ли исключение или предоставить это пользователю; если вы решили перехватить исключение, убедитесь, что `__exit__` возвращает `True` после того как всё сказано и сделано. Если вы не хотите, чтобы исключение было перехвачено менеджером контекста, просто позвольте ему случиться.  


  
`__enter__` и `__exit__` могут быть полезны для специфичных классов с хорошо описанным и распространённым поведением для их настройки и очистки ресурсов. Вы можете использовать эти методы и для создания общих менеджеров контекста для разных объектов. Вот пример:

```python

class Closer:
    '''Менеджер контекста для автоматического закрытия объекта вызовом метода close 
    в with-выражении.'''

    def __init__(self, obj):
        self.obj = obj

    def __enter__(self):
        return self.obj # привязка к активному объекту with-блока

    def __exit__(self, exception_type, exception_val, trace):
        try:
           self.obj.close()
        except AttributeError: # у объекта нет метода close
           print 'Not closable.'
           return True # исключение перехвачено

```

