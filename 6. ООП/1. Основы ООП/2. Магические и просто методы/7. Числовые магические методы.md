
Точно так же, как вы можете определить, каким образом ваши объекты будут сравниваться операторами сравнения, вы можете определить их поведение для числовых операторов. Приготовтесь, друзья, их много. Для лучшей организации, я разбил числовые магические методы на 5 категорий: унарные операторы, обычные арифметические операторы, отражённые арифметические операторы (подробности позже), составные присваивания и преобразования типов.  

#### Обычные арифметические операторы

Теперь рассмотрим обычные бинарные операторы (и ещё пару функций): +, -, * и похожие. Они, по большей части, отлично сами себя описывают.  
  

- `__add__(self, other)`  
    Сложение.  


- `__sub__(self, other)`  
    Вычитание.  


- `__mul__(self, other)`  
    Умножение.  


- `__floordiv__(self, other)`  
    Целочисленное деление, оператор `//`.  


- `__div__(self, other)`  
    Деление, оператор `/`.  


- `__truediv__(self, other)`  
    _Правильное_ деление. Заметьте, что это работает только когда используется `from __future__ import division`.  


- `__mod__(self, other)`  
    Остаток от деления, оператор `%`.  


- `__divmod__(self, other)`  
    Определяет поведение для встроенной функции `divmod()`.  


- `__pow__`  
    Возведение в степень, оператор `**`.  


- `__lshift__(self, other)`  
    Двоичный сдвиг влево, оператор `<<`.  


- `__rshift__(self, other)`  
    Двоичный сдвиг вправо, оператор `>>`.  


- `__and__(self, other)`  
    Двоичное И, оператор `&`.  


- `__or__(self, other)`  
    Двоичное ИЛИ, оператор `|`.  


- `__xor__(self, other)`  
    Двоичный xor, оператор `^`.


---
#### Унарные операторы и функции

  
Унарные операторы и функции имеют только один операнд — отрицание, абсолютное значение, и так далее.  
  

- `__pos__(self)`  
    Определяет поведение для унарного плюса (`+some_object`)  


- `__neg__(self)`  
    Определяет поведение для отрицания(`-some_object`)  


- `__abs__(self)`  
    Определяет поведение для встроенной функции `abs()`.  


- `__invert__(self)`  
    Определяет поведение для инвертирования оператором `~`. Для объяснения что он делает смотри [статью в Википедии о бинарных операторах](http://en.wikipedia.org/wiki/Bitwise_operation#NOT).  


- `__round__(self, n)`  
    Определяет поведение для встроенной функции `round()`. `n` это число знаков после запятой, до которого округлить.  


- `__floor__(self)`  
    Определяет поведение для `math.floor()`, то есть, округления до ближайшего меньшего целого.  


- `__ceil__(self)`  
    Определяет поведение для `math.ceil()`, то есть, округления до ближайшего большего целого.  


- `__trunc__(self)`  
    Определяет поведение для `math.trunc()`, то есть, обрезания до целого.  

---
#### Отражённые арифметические операторы

  
Помните как я сказал, что собираюсь остановиться на отражённой арифметике подробнее? Вы могли подумать, что это какая-то большая, страшная и непонятная концепция. На самом деле всё очень просто. Вот пример:  
  

```
some_object + other
```

  
Это «обычное» сложение. Единственное, чем отличается эквивалентное отражённое выражение, это порядок слагаемых:  
  

```
other + some_object
```

  
Таким образом, все эти магические методы делают то же самое, что и их обычные версии, за исключением выполнения операции с `other` в качестве первого операнда и `self` в качестве второго. В большинстве случаев, результат отражённой операции такой же, как её обычный эквивалент, поэтому при определении `__radd__` вы можете ограничиться вызовом `__add__` да и всё. Заметьте, что объект слева от оператора (`other` в примере) не должен иметь обычной неотражённой версии этого метода. В нашем примере, `some_object.__radd__` будет вызван только если в `other` не определён `__add__`.  
  

- `__radd__(self, other)`  
    Отражённое сложение.  


- `__rsub__(self, other)`  
    Отражённое вычитание.  


- `__rmul__(self, other)`  
    Отражённое умножение.  


- `__rfloordiv__(self, other)`  
    Отражённое целочисленное деление, оператор `//`.  


- `__rdiv__(self, other)`  
    Отражённое деление, оператор `/`.  


- `__rtruediv__(self, other)`  
    Отражённое _правильное_ деление. Заметьте, что работает только когда используется `from __future__ import division`.  


- `__rmod__(self, other)`  
    Отражённый остаток от деления, оператор `%`.  


- `__rdivmod__(self, other)`  
    Определяет поведение для встроенной функции `divmod()`, когда вызывается `divmod(other, self)`.  


- `__rpow__`  
    Отражённое возведение в степерь, оператор `**`.  


- `__rlshift__(self, other)`  
    Отражённый двоичный сдвиг влево, оператор `<<`.  


- `__rrshift__(self, other)`  
    Отражённый двоичный сдвиг вправо, оператор `>>`.  


- `__rand__(self, other)`  
    Отражённое двоичное И, оператор `&`.  


- `__ror__(self, other)`  
    Отражённое двоичное ИЛИ, оператор `|`.  


- `__rxor__(self, other)`  
    Отражённый двоичный xor, оператор `^`.  


---

#### Составное присваивание

  
В Питоне широко представлены и магические методы для составного присваивания. Вы скорее всего уже знакомы с составным присваиванием, это комбинация «обычного» оператора и присваивания. Если всё ещё непонятно, вот пример:  
  

```

x = 5
x += 1 # другими словами x = x + 1

```

  
Каждый из этих методов должен возвращать значение, которое будет присвоено переменной слева (например, для `a += b`, `__iadd__` должен вернуть `a + b`, что будет присвоено `a`). Вот список:  
  

- `__iadd__(self, other)`  
    Сложение с присваиванием.  


- `__isub__(self, other)`  
    Вычитание с присваиванием.  


- `__imul__(self, other)`  
    Умножение с присваиванием.  


- `__ifloordiv__(self, other)`  
    Целочисленное деление с присваиванием, оператор `//=`.  


- `__idiv__(self, other)`  
    Деление с присваиванием, оператор `/=`.  


- `__itruediv__(self, other)`  
    _Правильное_ деление с присваиванием. Заметьте, что работает только если используется `from __future__ import division`.  


- `__imod_(self, other)`  
    Остаток от деления с присваиванием, оператор `%=`.  


- `__ipow__`  
    Возведение в степерь с присваиванием, оператор `**=`.  


- `__ilshift__(self, other)`  
    Двоичный сдвиг влево с присваиванием, оператор `<<=`.  


- `__irshift__(self, other)`  
    Двоичный сдвиг вправо с присваиванием, оператор `>>=`.  


- `__iand__(self, other)`  
    Двоичное И с присваиванием, оператор `&=`.  


- `__ior__(self, other)`  
    Двоичное ИЛИ с присваиванием, оператор `|=`.  


- `__ixor__(self, other)`  
    Двоичный xor с присваиванием, оператор `^=`.