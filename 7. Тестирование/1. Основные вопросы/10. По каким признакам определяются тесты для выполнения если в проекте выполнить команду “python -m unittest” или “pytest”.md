
# Pytest

В случае PyTest хорошей практикой считается создать под тесты отдельную директорию в корне, разбить тесты разных категорий по файлам, например тесты одного модуля в один, бэкенд и фронт отдельно и т.п. Как тогда Pytest находит их при вводе команды:


```terminal

pytest -s -v tests/*

```

Здесь команда в папке tests в директории проекта выполняться ВСЕ тесты. Pytest  ищет файлы со словом test в названии , в них в качестве тестов запускает функции c test в начале или конце:

tests/test_BackEnd.py

```python

def test_getting_products():  
    r = requests.get(url=SERVICE_URL+'/api/products/')  
    response = Response(r)  
    response.assert_status_code(200).validate(ProductSchema)  
    response.assert_empty_data()  
    print(response.response_json[0])

```


# Unittest

Для автоматизации тестов, unittest поддерживает некоторые важные концепции:

- **Испытательный стенд** (test fixture) - выполняется подготовка, необходимая для выполнения тестов и все необходимые действия для очистки после выполнения тестов. Это может включать, например, создание временных баз данных или запуск серверного процесса.
- **Тестовый случай** (test case) - минимальный блок тестирования. Он проверяет ответы для разных наборов данных. Модуль unittest предоставляет базовый класс TestCase, который можно использовать для создания новых тестовых случаев.
- **Набор тестов** (test suite) - несколько тестовых случаев, наборов тестов или и того и другого. Он используется для объединения тестов, которые должны быть выполнены вместе.
- **Исполнитель тестов** (test runner) - компонент, который управляет выполнением тестов и предоставляет пользователю результат. Исполнитель может использовать графический или текстовый интерфейс или возвращать специальное значение, которое сообщает о результатах выполнения тестов.

Пример файла тестов строк на основе test case

```python

import unittest

class TestStringMethods(unittest.TestCase):

  def test_upper(self):
      self.assertEqual('foo'.upper(), 'FOO')

  def test_isupper(self):
      self.assertTrue('FOO'.isupper())
      self.assertFalse('Foo'.isupper())

  def test_split(self):
      s = 'hello world'
      self.assertEqual(s.split(), ['hello', 'world'])
      # Проверим, что s.split не работает, если разделитель - не строка
      with self.assertRaises(TypeError):
          s.split(2)

if __name__ == '__main__':
    unittest.main()

```

То есть как видим тут тоже есть стандарты, класс для функций теста наследуется от unittest.TestCase, а названия функций содержат test_ в начале 

То есть смысл тот же названия файлов с test и названия ф-ий 

```terminal

python -m unittest

```

