
Асинхронное программирование — это концепция программирования, при применении которой запуск длительных операций происходит без ожидания их завершения и не блокирует дальнейшее выполнение программы.

Вместо этого запросы и вызовы функций производятся и выполняются в фоновом режиме, результаты их работы оказываются доступными не сразу, а через некоторое время. Это позволяет вызывающей стороне решать другие задачи, а результаты, ожидаемые после выполнения асинхронных вызовов, обрабатывать позже — либо тогда, когда они будут готовы, либо тогда, когда они понадобятся вызывающей стороне.

#### 1.1. Асинхронные задачи

Слово «асинхронный» используют для описания неких процессов, не совпадающих друг с другом во времени. Его противоположность — слово «синхронный», используемое для описания чего-либо, точно совпадающего во времени.

В программировании смысл [асинхронности](https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)) в том, что когда делается запрос на выполнение некоего действия, это действие выполняется не в тот момент, когда делается запрос, а позже.

Например, можно выполнять [асинхронные вызовы функций](https://en.wikipedia.org/wiki/Asynchronous_procedure_call).

При выполнении асинхронного вызова функции мы делаем запрос на выполнение вызова функции, но не ждём завершения этого вызова. А состояние вызванной функции или результаты её работы мы узнаём позже.

**Асинхронный вызов функции** — это запрос на вызов функции, выполняемый неким образом в некий момент времени, при этом вызывающая сторона, после выполнения вызова, может продолжать работу и решать другие задачи.

Получается, что вызов функции будет выполнен в некий момент времени, в фоновом режиме, а программа может решать какие-то задачи или реагировать на некие события.

В этом — вся суть. Мы не осуществляем контроль над тем, как или когда будет обработан запрос. Мы лишь сообщаем системе о том, что нам нужно, чтобы запрос был бы обработан тогда, когда наша программа занимается какими-то другими делами.

Выполнение асинхронного вызова функции часто приводит к предоставлении вызывающей стороне некоего идентификатора запроса, который вызывающая сторона может использовать для того, чтобы проверить состояние запроса или получить результаты. Такие идентификаторы часто называют объектами, ждущими результата выполнения задачи (future, объект Future, преднамеченное значение, «футура»).

**Объект future**: идентификатор асинхронного вызова функции, позволяющий проверять состояние вызова и получать результаты работы функции.

Комбинацию асинхронного вызова функции и объекта `Future` часто называют асинхронной задачей. Это так из-за того, что такая комбинация даёт больше возможностей, чем обычный вызов функции. Например — позволяет отменять запрос и выполнять другие действия.

**Асинхронная задача**: этот термин используется для обозначения сущности, представляющей собой объединение асинхронного вызова функции и порождённого этим вызовом объекта `Future`.

#### 1.2. Асинхронное программирование

Формирование асинхронных задач и выполнение асинхронных вызовов функций называют асинхронным программированием.

**Асинхронное программирование**: использование особых приёмов асинхронного выполнения кода — таких, как выполнение асинхронных задач или вызовов функций.

Приёмы асинхронного программирования используются, в основном, в системах, предусматривающих применение неблокирующих операций ввода/вывода. Это, например, чтение данных из сокета или их запись в сокет при работе с другими процессами или системами.

Неблокирующий ввод/вывод — это когда программа запрашивает у системы чтение или запись неких данных, а соответствующие операции выполняются асинхронно. Вызывающей стороне не нужно ждать завершения операции перед переходом к другим задачам.

Операции чтения и записи выполняются тем или иным образом (например — операционной системой, или некими системами, построенными на её основе), а сведения о состоянии операций и/или данные, полученные в ходе их выполнения, вызывающая сторона получает позднее, как только они будут готовы, или когда вызывающая сторона готова будет их принять.

**Неблокирующая обработка ввода/вывода**: выполнение операций ввода/вывода посредством асинхронных запросов и ответов, а не таким образом, который предусматривает ожидание завершения операции.

Таким образом — можно видеть, как неблокирующий ввод/вывод связан с асинхронным программированием. На самом деле, мы либо используем неблокирующий ввод/вывод через механизмы асинхронного программирования, либо неблокирующий ввод/вывод реализован посредством таких механизмов.

Комбинация неблокирующего ввода/вывода с асинхронным программированием так распространена, что её обычно называют [асинхронным вводом/выводом](https://en.wikipedia.org/wiki/Asynchronous_I/O).

**Асинхронный ввод/вывод**: условное сокращение, которое означает комбинацию асинхронного программирование и неблокирующей обработки ввода/вывода.

Теперь давайте разберёмся с асинхронным программированием в Python.

#### 1.3. Асинхронное программирование в Python

В широком смысле асинхронное программирование в Python — это выполнение запросов без блокировки основной программы ради ожидания их завершения.

Асинхронные механизмы в Python можно реализовать разными способами, но при этом некоторые из них лучше других соответствуют модели конкурентности Python.

Первый и наиболее очевидный подход к разработке асинхронных Python-программ заключается в применении [модуля asyncio](https://docs.python.org/3/library/asyncio.html). Этот модуль напрямую предлагает программисту среду для асинхронного программирования, в которой используется синтаксическая конструкция `async/await` и неблокирующий ввод/вывод с применением сокетов и подпроцессов.

_Название модуля asyncio — это сокращение от asynchronous I/O (асинхронный ввод/вывод). Это — Python-библиотека, которая позволяет нам выполнять код, используя модель асинхронного программирования. Такой подход даёт возможность одновременно обрабатывать несколько операций ввода/вывода, а приложение при этом не теряет возможности реагировать на внешние воздействия._

Всё это реализовано с использованием корутин. Они выполняются в цикле событий, а сам он выполняется в единственном потоке.

**Asyncio**: асинхронная среда программирования, представленная в Python благодаря модулю `asyncio`.

Если говорить о других подобных механизмах — то в Python можно работать с потоками и процессами, которые способны асинхронно выполнять задачи.

Например, один поток может запустить другой поток для выполнения вызова функции, а после этого продолжить выполнять другие действия. Операционная система запланирует и выполнит второй поток в некий момент времени, а первый поток может, по желанию программиста, проверить состояние задачи, или может этого не делать.

А точнее — Python даёт в наше распоряжение пулы потоков и процессов, основанные на концепции исполнителей. Реализовано это, соответственно, посредством классов [ThreadPoolExecutor](https://superfastpython.com/threadpoolexecutor-in-python/) и [ProcessPoolExecutor](https://superfastpython.com/processpoolexecutor-in-python/).

Эти классы используют одинаковый интерфейс и поддерживают асинхронные задачи с помощью метода `submit()`, который возвращает объект `Future`.

_Модуль concurrent.futures предоставляет высокоуровневый интерфейс для асинхронного выполнения вызываемых объектов. Асинхронное выполнение объектов может быть произведено с помощью потоков — посредством ThreadPoolExecutor, или с помощью отдельных процессов — посредством ProcessPoolExecutor._

Модуль [multiprocessing](https://docs.python.org/3/library/multiprocessing.html) тоже предоставляет пулы воркеров, использующие процессы и потоки, посредством классов [Pool](https://superfastpython.com/multiprocessing-pool-python/) и [ThreadPool](https://superfastpython.com/threadpool-python/). Это — предшественники классов `ThreadPoolExecutor` и `ProcessPoolExecutor`.

Возможности этих классов описываются в терминах воркеров, асинхронно выполняющих задачи. Они явным образом предоставляют синхронные (блокирующие) и асинхронные (неблокирующие) версии каждого метода для выполнения задач.

Например, можно запустить функцию, предназначенную для особого случая, либо сделав это синхронно, воспользовавшись методом `apply()`, либо асинхронно — с помощью метода `apply_async()`.

















