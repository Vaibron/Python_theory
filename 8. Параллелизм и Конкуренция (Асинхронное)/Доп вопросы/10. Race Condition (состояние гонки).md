
Кратко: Состояние гонки (race condition) **возникает, когда два потока одновременно пытаются получить доступ к общей переменной**. Представьте, что у нас есть два потока. Один поток считывает значение из некой общей переменной, а потом то же самое делает второй поток.

## Подробнее (здесь не все, там очень большая [статься](https://habr.com/ru/articles/764234/))

**Race condition (состояние гонки)** - это ситуация, при которой несколько потоков (или процессов) одновременно пытаются выполнить операции чтения или записи к общим ресурсам без должной синхронизации. Представить можно в формате очереди, один за одним.

Представьте площадку, аналогичную Я.маркет, где присутствуют купоны на скидку в 10% «best10». Два потока могут одновременно запросить базу данных и подтвердить, что код скидки «best10» не был применен к корзине, затем оба попытаются применить скидку, в результате чего, она будет применена дважды. Обратите внимание на то, что «гоночные» условия не ограничиваются конкретной архитектурой веб‑приложений. Проще всего рассуждать о многопоточном приложении с одной базой данных, но в более сложных системах состояние обычно хранится в еще большем количестве мест.

Почти все программы и веб-приложения сегодня используют так называемую «_многопоточную_» обработку, при которой они способны выполнять несколько действий одновременно. Хоть это и позволяет приложениям работать значительно быстрее - это приводит к возникновению потенциальных ошибок, если более одного процесса (или «потока») пытаются одновременно получить доступ к одним и тем же данным.

Как правило, состояние гонки протекают по определенной схеме:

- Критическая секция: Это участок кода, в котором происходит обращение к общим ресурсам и их модификация.
    
- Синхронизация: Отсутствие надлежащих механизмов синхронизации может позволить нескольким процессам одновременно войти в критическую секцию.
    
- Непредсказуемый результат: Из-за одновременного выполнения конечное состояние общего ресурса становится неопределенным.
    

Например, когда система SQL выполняет обновление базы данных, во время процесса обновления она создает временный файл. Именно этот временный файл со временем заменяет данные в базе данных. При своевременной атаке злоумышленники могут подменить временный файл SQL-обновления таблицы административного доступа на свой собственный, предоставив тем самым себе права администратора в системе.

### Типы Race Condition

#### Limit-overrun / TOCTOU

Это наиболее простой тип Race Condition, когда уязвимости ограничивают количество раз выполнения какого-либо действия. Например, использование одного и того же купона скидки в интернет-магазине несколько раз. Очень простой пример можно найти в [этой статье](https://pravinponnusamy.medium.com/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) (требуется vpn) или в [этом отчете h1](https://hackerone.com/reports/759247).

Существует множество разновидностей этого вида атак, в том числе:

- Погашение подарочной карты несколько раз

- Многократное выставление оценок продукту

- Снятие или перевод денежных средств, превышающих остаток на счете

- Повторное использование одного решения CAPTCHA

- Обход anti-brute-force

#### Hidden substates

Другие, более сложные RC, будут использовать подсистемы в состоянии машины, что может позволить злоумышленнику злоупотреблять состояниями, к которым он не должен был иметь доступа, но для злоумышленника есть небольшое окно для доступа к ним.

1. Прогнозирование потенциальных скрытых и интересных подсистем.

    Первым шагом является определение всех конечных точек, которые либо записывают в подсистему, либо считывают из нее данные, а затем используют их для каких-то важных целей. Например, пользователи могут храниться в таблице базы данных, которая изменяется при регистрации, редактировании профиля, инициировании сброса пароля и завершении сброса пароля. Мы можем использовать три ключевых вопроса, чтобы исключить конечные точки, которые вряд ли могут стать причиной столкновений. Для каждого объекта и связанных с ним конечных точек задайте следующие вопросы:


- Как хранится состояние?  
    Данные, хранящиеся в постоянной структуре данных на стороне сервера, идеально подходят для эксплуатации. Некоторые конечные точки хранят свое состояние полностью на стороне клиента, например, сброс пароля происходит путем отправки JWT по электронной почте — их можно смело пропустить.  
    Приложения часто хранят некоторые состояния в пользовательской сессии. Часто они в некоторой степени защищены от вложенных состояний — подробнее об этом будет расказано позже.

- Мы редактируем или добавляем?  
    Операции, редактирующие существующие данные (например, изменение основного адреса электронной почты учетной записи), обладают большим потенциалом «столкновений», в то время как действия, просто добавляющие существующие данные (например, добавление дополнительного адреса электронной почты), вряд ли будут уязвимы для чего‑либо, кроме limit‑overrun attacks.

- На чем основана операция?  
    Большинство конечных точек работают с определенной записью, которая ищется с помощью «ключа» - например, имени пользователя, маркера сброса пароля или имени файла. Для успешной атаки нам необходимы две операции, использующие один и тот же ключ. Например, представим две правдоподобные реализации сброса пароля:

    ![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/00e/1ac/28b/00e1ac28b1aa23ceecc5ffed93e2d910.png)
    

2. Поиск подсказок.
    
    На этом этапе самое время провести несколько RC‑атак на потенциально интересные конечные точки, чтобы попытаться найти неожиданные результаты по сравнению с обычными. Любое отклонение от ожидаемого ответа, например, изменение одного или нескольких ответов, или эффект второго порядка, например, различное содержимое писем или видимое изменение сеанса может быть подсказкой, указывающей, что что‑то не так.
    
3. Prove the concept (Доказательство концепции).
    
    Последний шаг - подтверждение концепции и превращение ее в жизнеспособную атаку.
    

При отправке пакета запросов можно обнаружить, что ранняя пара запросов вызывает уязвимое конечное состояние, но последующие запросы перезаписывают/делают его недостоверным, и конечное состояние оказывается не эксплуатируемым. В этом случае необходимо исключить все лишние запросы — для эксплуатации большинства уязвимостей достаточно двух. Однако, если сократить количество запросов до двух, атака станет более чувствительной ко времени, поэтому может потребоваться многократное повторение атаки или ее автоматизация.

#### Time Sensitive Attacks

Иногда можно не обнаружить условий гонки, но техника доставки запросов с точным соблюдением временных рамок все равно может выявить наличие других уязвимостей.

Одним из таких примеров является использование временных меток высокого разрешения вместо криптографически защищенных случайных строк для генерации маркеров безопасности.

Рассмотрим маркер сброса пароля, который рандомизируется только по метке времени. В этом случае можно инициировать два сброса пароля для двух разных пользователей, которые используют один и тот же маркер. Все, что нужно сделать - это задать время для запросов, чтобы они генерировали одну и ту же временную метку.

> Для подтверждения, например, предыдущей ситуации можно просто запросить 2 токена сброса пароля одновременно (используя атаку одним пакетом) и проверить, одинаковы ли они.

