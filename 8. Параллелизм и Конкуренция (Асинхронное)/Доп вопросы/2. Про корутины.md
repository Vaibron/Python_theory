
Что нам нужно знать о корутине? На начальном этапе немного. Помните как в python устроен генератор? Ну, это то, что функция начинает возвращать, если в нее добавить `yield` вместо `return`. Так вот, корутина — это разновидность генератора.

```python

import asyncio
import time


async def fun1(x):
    print(x**2)
    await asyncio.sleep(3)
    print('fun1 завершена')


async def fun2(x):
    print(x**0.5)
    await asyncio.sleep(3)
    print('fun2 завершена')


async def main():
    task1 = asyncio.create_task(fun1(4))
    task2 = asyncio.create_task(fun2(4))

    await task1
    await task2


print(type(fun1)) >>> Вывод: `<class 'NoneType'>`

print(type(fun1(4))) >>> Вывод: `<class 'coroutine'>`

```

Корутина дает интерпретатору возможность возобновить базовую функцию, которая была приостановлена в месте размещения ключевого слова `await`.

И вот тут начинается терминологическая путаница, которая попила немало крови добрых разработчиков на собеседованиях. Сплошь и рядом корутиной называют **саму функцию**, содержащую `await`. Строго говоря, это неправильно. Корутина — это то, что **возвращает** функция с `await`. Чувствуете разницу между `f` и `f()`?

С генераторами, кстати, та же самая история. Генератором как-то повелось называть функцию, содержащую `yield`, хотя по правильному-то она "генераторная функция". А генератор — это именно тот объект, который генераторная функция возвращает.

Далее по тексту мы постараемся придерживаться правильной терминологии: асинхронная (или корутинная) функция — это `f`, а корутина — `f()`. Но если вы в разговоре назовете корутиной асинхронную функцию, беды большой не произойдет, вас поймут.