
```python

import asyncio


async def fun1(x):
    print(x**2)
    await asyncio.sleep(3)
    print('fun1 завершена')


async def fun2(x):
    print(x**0.5)
    await asyncio.sleep(3)
    print('fun2 завершена')


async def main(): 
    task1 = asyncio.create_task(fun1(4)) ## Задача 1 (корутину асинхронной функции `fun1` обернули задачей `task1`)
    task2 = asyncio.create_task(fun2(4)) ## Задача 2

    print(type(task1)) >>> Вывод: `<class '_asyncio.Task'>`
    print(task1.__class__.__bases__) >>> Вывод: `<class '_asyncio.Future'>`

    await task1 ## обозначили точку переключения к задаче `task1`
    await task2


asyncio.run(main()) # корутину асинхронной функции `main` передали в функцию `asyncio.run`

```

Футура (если совсем упрощенно) — это оболочка для некой асинхронной сущности, позволяющая выполнять ее "как бы одновременно" с другими асинхронными сущностями, переключаясь от одной сущности к другой в точках, обозначенных ключевым словом `await`

Кроме того футура имеет внутреннюю переменную "результат", которая доступна через `.result()` и устанавливается через `.set_result(value)`. Пока ничего не надо делать с этим знанием, оно пригодится в дальнейшем.

У футуры на самом деле еще много чего есть внутри, но на данном этапе не будем слишком углубляться. Футуры в чистом виде используются в основном разработчиками фреймворков, нам же для разработки приложений приходится иметь дело с их дочками — **задачами**.

**Задача — это частный случай футуры, предназначенный для оборачивания корутины.**

> [!Важно]
> В `asyncio.run` нужно передавать асинхронную функцию с эвейтами на **задачи**, а не на корутины. Иначе конкурентного выполнения кода не будет.

