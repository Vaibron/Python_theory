
В контексте асинхронного программирования мы будем разделять 2 вида задач: IO bound и CPU bound задачи.

## CPU bound

Когда говорят, что задача или программа "**CPU bound**", это значит, что скорость выполнения зависит преимущественно от мощности процессора. Если Ваша программа большую часть времени тратит на вычисления или обработку данных, то она именно такая.

**Аналогия из жизни:**  
Представьте, что Вы сталкиваетесь с трудной математической задачей. Время, которое Вы потратите на её решение, будет похоже на ситуацию с CPU bound. Почему? Потому что Вы будете интенсивно задействовать свои мозговые ресурсы — умственные способности, чтобы найти решение. Этот процесс требует активного мышления, ведь именно от Вашей способности быстро и эффективно обрабатывать информацию зависит, как быстро Вы справитесь с задачей.

#### Примеры CPU операций:

1. **Арифметические и логические операции:** Это включает в себя операции сложения, вычитания, умножения, деления, возведения в степень, а также операции сравнения и логические операции (и, или, не).
    
    ```python
    # Арифметические операции
    result = (3 + 4) * 5 / 2
    
    # Логические операции
    is_true = (5 > 3) and (2 < 4)
    ```
    
2. **Циклы:** Циклы, такие как `for` и `while`, требуют активного использования процессора для итерации по элементам или выполнения повторяющихся действий.
    
    ```python
    # Цикл for
    for i in range(10):
        print(i)
    
    # Цикл while
    i = 0
    while i < 10:
        print(i)
        i += 1
    ```
    
3. **Условные операторы:** Условные операторы, такие как `if`, `elif` и `else`, **задействуют процессор** для проверки условий и выполнения соответствующих действий.
    
    ```python
    # Условные операторы
    x = 10
    if x > 5:
        print('x больше 5')
    elif x < 5:
        print('x меньше 5')
    else:
        print('x равно 5')
    ```
    
4. **Функции:** Вызов функций и методов, а также возвращение значений, требует активного использования процессора.
    
    ```python
    # Определение функции
    def square(x):
        return x ** 2
    
    # Вызов функции
    result = square(5)
    ```
    
5. **Обработка данных:** Это может включать в себя сортировку данных, поиск данных, преобразование данных и так далее.
    
    ```python
    # Сортировка списка
    numbers = [5, 2, 3, 1, 4]
    numbers.sort()
    
    # Поиск в списке
    index = numbers.index(3)
    ```

6. **Обработка изображений и видео:** Включает в себя фильтрацию изображений, изменение размера, преобразование форматов, кодирование и декодирование видео и так далее. Эти операции обычно требуют значительных вычислительных ресурсов процессора.
    
    ```python
    from PIL import Image
    
    # Открытие изображения
    img = Image.open('image.jpg')
    
    # Применение фильтра
    img = img.filter(ImageFilter.BLUR)
    
    # Сохранение изображения
    img.save('blurred_image.jpg')
    ```
    
- **Машинное обучение:** Тренировка моделей машинного обучения часто требует значительных вычислительных ресурсов, особенно при работе с большими наборами данных и сложными моделями.
    
    ```python
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.datasets import load_iris
    
    # Загрузка данных
    iris = load_iris()
    X, y = iris.data, iris.target
    
    # Обучение модели
    clf = RandomForestClassifier()
    clf.fit(X, y)
    ```
    
- **Научные вычисления:** Это может включать в себя сложные математические вычисления, такие как интегрирование, дифференцирование, решение дифференциальных уравнений и так далее.
    
    ```python
    import numpy as np
    
    # Создание массива
    x = np.array([1, 2, 3, 4, 5])
    
    # Вычисление синуса для каждого элемента массива
    y = np.sin(x)
    ```
    
- **Криптография:** Операции шифрования и дешифрования, а также генерация и проверка цифровых подписей обычно требуют значительных вычислительных ресурсов.
    
    ```python
    from cryptography.fernet import Fernet
    
    # Генерация ключа
    key = Fernet.generate_key()
    
    # Создание объекта шифрования
    cipher = Fernet(key)
    
    # Шифрование сообщения
    message = b"Hello, World!"
    encrypted_message = cipher.encrypt(message)
    ```