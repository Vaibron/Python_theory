
**Pool**: Класс из модуля multiprocessing, предоставляющий пул процессов для выполнения задач параллельно. Позволяет управлять пулом процессов и распределять задачи между процессами.

#### Синтаксис:

``` Python
from multiprocessing import Pool

pool = Pool([processes[, initializer
            [, initargs[, maxtasksperchild
            [, context]]]]])
```

#### Параметры:

- `processes` - количество используемых рабочих процессов,
- `initializer` - вызываемый объект (функция),
- `initargs` - аргументами для `initializer`
- `maxtasksperchild` - количество задач рабочего процесса до обновления,
- `context` - контекста для запуска рабочих процессов.

#### Возвращаемое значение:

- [объект `Pool`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool).

#### Описание:

Класс [`Pool()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/ "Класс Pool() модуля multiprocessing в Python.") модуля [`multiprocessing`](https://docs-python.ru/standart-library/paket-multiprocessing-python/ "Модуль multiprocessing в Python, параллельная обработка без GIL.") создает объект, управляющий пулом рабочих процессов, в который могут быть отправлены задания. Пул рабочих процессов поддерживает асинхронное выполнение задач с тайм-аутами и обратными вызовами и имеет параллельную реализацию.

Аргумент `processes` - это количество используемых рабочих процессов. Если аргумент `processes` не указан, то используется число, возвращаемое функцией [`os.cpu_count()`](https://docs-python.ru/standart-library/modul-os-python/funktsii-getloadavg-cpu-count-modulja-os/ "Функции getloadavg() и cpu_count() модуля os в Python.").

Если аргумент `initializer` не равен `None`, то при запуске каждый рабочий процесс будет выполнять вызываемый объект `initializer` с аргументами `*initargs` в виде: `initializer(*initargs)`

Аргумент `maxtasksperchild` - это количество задач, которые рабочий процесс может выполнить до того, как он выйдет и будет заменен новым рабочим процессом, чтобы освободить неиспользуемые ресурсы. По умолчанию для `maxtasksperchild` установлено значение `None`, это означает, что рабочие процессы будут жить столько же, сколько и пул.

Аргумент `context` можно использовать для указания контекста, используемого для запуска рабочих процессов. Обычно пул создается с помощью создания экземпляра [класса `multiprocessing.Pool()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/ "Класс Pool() модуля multiprocessing в Python.") или объекта контекста `context.Pool()`, созданного функцией [`multiprocessing.get_context()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/poluchenie-svedenij-protsessah-modul-multiprocessing/ "Получение сведений о процессах, модуль multiprocessing в Python."). В обоих случаях контекст устанавливается соответствующим образом.

Обратите внимание, что методы [объекта пула](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool) должны вызываться **только процессом, создавшим пул**. Проще говоря методы должны вызываться из кода, где был создан и запущен пул рабочих процессов.

**Предупреждение**. Объекты `multiprocessing.Pool` имеют внутренние ресурсы, которыми необходимо правильно управлять, используя пул с [менеджером контекста](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/kontekstnyj-menedzher-with/ "Контекстный менеджер with в Python") или вручную вызывая методы пула [`Pool.close()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.close) и [`Pool.terminate()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.terminate). Невыполнение этого требования может привести к зависанию процесса при завершении.

Обратите внимание, что неправильно полагаться на сборщик мусора для уничтожения пула, поскольку CPython не гарантирует, что будет вызван финализатор пула.

Примечание. Рабочие процессы в пуле обычно живут в течение всего срока рабочей очереди пула. Часто используемый в других системах (например, Apache, mod_wsgi и т. д.) шаблон для освобождения ресурсов, удерживаемых рабочими процессами, заключается в том, чтобы позволить им выполнить только заданный объем работы перед его выходом, очисткой и созданием нового процесса. Для пула процессов, эту возможность пользователю предоставляет аргумент `maxtasksperchild`.

## Методы объекта `Pool`.

- `Pool.apply()` [вызывает функцию с аргументами](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.apply),
- `Pool.apply_async()` [асинхронный вариант метода `Pool.apply()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.apply_async),
- `Pool.map()` [многопроцессорный эквивалент встроенной функции `map()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.map),
- `Pool.map_async()` [асинхронный вариант метода `Pool.map()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.map_async),
- `Pool.imap()` [более ленивая версия метода `Pool.map()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.imap),
- `Pool.imap_unordered()` [то же самое, что и `Pool.imap()`, только результаты идут по готовности](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.imap_unordered),
- `Pool.starmap()` [аналогичен методу `Pool.map()`, только другая передача аргументов](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.starmap),
- `Pool.starmap_async()` [комбинация методов `Pool.starmap()` и `Pool.map_async()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.starmap_async),
- `Pool.close()` [предотвращает отправку задач в пул](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.close),
- `Pool.terminate()` [останавливает рабочие процессы](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.terminate),
- `Pool.join()` [ждет, пока рабочие процессы закончатся](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#Pool.join),
- Объект `AsyncResult` [результат вызовов методов `Pool.apply_async()` и `Pool.map_async()`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#AsyncResult)
    - `AsyncResult.get()` [возвращает результат, как только он придет](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#AsyncResult.get),
    - `AsyncResult.wait()` [ждет, пока будет доступен результат](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#AsyncResult.wait),
    - `AsyncResult.ready()` [проверяет, завершился ли вызов](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#AsyncResult.ready),
    - `AsyncResult.successful()` [проверяет, был ли завершен вызов без исключения](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#AsyncResult.successful).
- [Пример создания и запуска и использования пула рабочих процессов](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#example1),
- [Тестирование основной функциональности объекта `Pool`](https://docs-python.ru/standart-library/paket-multiprocessing-python/klass-pool-modulja-multiprocessing/#test).