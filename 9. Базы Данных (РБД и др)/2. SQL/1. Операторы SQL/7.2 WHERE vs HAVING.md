
Обсудим такой популярный вопрос на собеседовании, как «Чем отличается WHERE от HAVING»?

```sql

SELECT username, COUNT(*)
FROM table
WHERE username = ‘Anna’
GROUP BY username
HAVING COUNT(*)>1

```

Давайте разберёмся. В сущности, **HAVING** очень похож на **WHERE** - это тоже фильтр. Вы можете написать в **HAVING** name = ‘Anna’, как и в **WHERE**, и ошибки не будет.

## В чём же ключевое различие?

Во-первых, в **HAVING** и только в нём можно писать условия по агрегатным функциям (SUM, COUNT, MAX, MIN и т. д.). То есть если вы хотите сделать что-то вроде COUNT(_) > 10, то это возможно сделать только в_ _HAVING_*.

"Почему бы не оставить только **HAVING**?" - спросите вы. Всё кроется в том, как **SQL Server** выполняет запрос, в каком порядке происходит его разбор и работа с данными. **WHERE** выполняется до формирования групп **GROUP BY**. Это нужно для того, чтобы можно было оперировать как можно меньшим количеством данных и сэкономить ресурсы сервера и время пользователя.

Следующим этапом формируются группы, которые указаны в **GROUP BY**. После того как сформированы группы, можно накладывать условия на результаты агрегатных функций. И тут как раз наступает очередь **HAVING**: выполняются условия, которые вы задали.

Если **GROUP BY** не применяется, то **HAVING** может функционировать как **WHERE**. Однако это не самый эффективный способ использования **HAVING**, поскольку его предназначение — фильтрация данных после агрегации.

Главное отличие **HAVING** от **WHERE** в том, что в **HAVING** можно наложить условия на результаты группировки, потому что порядок исполнения запроса устроен таким образом, что на этапе, когда выполняется **WHERE**, ещё нет групп, а **HAVING** выполняется уже после формирования групп.

# ЧТО ЕЩЁ?

#### Псевдонимы

В HAVING можно использовать псевдонимы только если они используются для наименования результата агрегатной функции, в WHERE можно всегда. 

## Распространенные ловушки и методы их устранения

При работе с SQL существуют ошибки, в которые легко вляпаться:

1. Применение **HAVING** без использования **GROUP BY** может привести к снижению производительности базы данных.
2. Попытка использования агрегатных функций с **WHERE** приведет к ошибке, т.к. **WHERE** функционирует до стадии агрегации.
3. Заблуждения о порядке выполнения условий могут сказаться на корректности результатов. Важно помнить, что **WHERE** идет до **GROUP BY**, а **HAVING** следует после.

Чтобы избежать этих проблем:

- Используйте **WHERE** для уменьшения объема данных до их агрегации.
- Применяйте **HAVING** для фильтрации результатов после группировки.
- Всегда проверяйте логику запроса на небольшой выборке данных перед его выполнением на полном объеме данных.